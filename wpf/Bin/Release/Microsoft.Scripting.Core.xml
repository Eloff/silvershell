<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Scripting.Core</name>
    </assembly>
    <members>
        <member name="M:Microsoft.Scripting.Utils.TypeExtensions.CreateDelegate(System.Reflection.MethodInfo,System.Type)">
            <summary>
            Creates an open delegate for the given (dynamic)method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.TypeExtensions.CreateDelegate(System.Reflection.MethodInfo,System.Type,System.Object)">
            <summary>
            Creates a closed delegate for the given (dynamic)method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.TypeExtensions.IsSealedOrValueType(System.Type)">
            <summary>
            A helper routine to check if a type can be treated as sealed - i.e. there
            can never be a subtype of this given type.  This corresponds to a type
            that is either declared "Sealed" or is a ValueType and thus unable to be
            extended.
            
            TODO: this should not be needed. Type.IsSealed does the right thing.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.TypeExtensions.IsMandatoryParameter(System.Reflection.ParameterInfo)">
            <summary>
            Returns <c>true</c> if the specified parameter is mandatory, i.e. is not optional and doesn't have a default value.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.ListStack`1">
            <summary>
            A stack implemented as a list. Allows both Push/Pop access and indexing into any member of the list.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ListStack`1.Peek">
            <exception cref="T:System.InvalidOperationException">Stack is empty.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ListStack`1.Pop">
            <exception cref="T:System.InvalidOperationException">Stack is empty.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ListStack`1.GetEnumerator">
            <summary>
            Enumerates from the top of the stack to the bottom.
            </summary>
            <exception cref="T:System.InvalidOperationException">Stack has been modified during enumeration.</exception>
        </member>
        <member name="T:Microsoft.Linq.Expressions.Compiler.LambdaCompiler">
            <summary>
            Dynamic Language Runtime Compiler.
            This part compiles lambdas.
            </summary>
            <summary>
            LambdaCompiler is responsible for compiling individual lambda (LambdaExpression). The complete tree may
            contain multiple lambdas, the Compiler class is reponsible for compiling the whole tree, individual
            lambdas are then compiled by the LambdaCompiler.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.LambdaCompiler.EmitCatchStart(Microsoft.Linq.Expressions.CatchBlock)">
            <summary>
            Emits the start of a catch block.  The exception value that is provided by the
            CLR is stored in the variable specified by the catch block or popped if no
            variable is provided.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.LambdaCompiler.EmitDelegateConstruction(Microsoft.Linq.Expressions.Compiler.LambdaCompiler,System.Type)">
            <summary>
            Emits code which creates new instance of the delegateType delegate.
            
            Since the delegate is getting closed over the "Closure" argument, this
            cannot be used with virtual/instance methods (inner must be static method)
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.LambdaCompiler.EmitDelegateConstruction(Microsoft.Linq.Expressions.LambdaExpression,System.Type)">
            <summary>
            Emits a delegate to the method generated for the LambdaExpression.
            May end up creating a wrapper to match the requested delegate type.
            </summary>
            <param name="lambda">Lambda for which to generate a delegate</param>
            <param name="delegateType">Type of the delegate.</param>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.LambdaCompiler.ComputeSignature(Microsoft.Linq.Expressions.LambdaExpression,System.Collections.Generic.List{System.Type}@,System.Collections.Generic.List{System.String}@,System.String@,System.Type@)">
            <summary>
            Creates the signature for the lambda as list of types and list of names separately
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.LambdaCompiler.EmitExpression(Microsoft.Linq.Expressions.Expression)">
            <summary>
            Generates code for this expression in a value position.
            This method will leave the value of the expression
            on the top of the stack typed as Type.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.LambdaCompiler.EmitExpressionAsVoid(Microsoft.Linq.Expressions.Expression)">
            <summary>
            Emits an expression and discards the result.  For some nodes this emits
            more optimial code then EmitExpression/Pop
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.LambdaCompiler.Significant(Microsoft.Linq.Expressions.Expression)">
            <summary>
            Expression is significant if:
              * it is not an empty expression
            == or ==
              * it is an empty expression, and 
              * it has a valid span, and
              * we are emitting debug symbols
            </summary>
        </member>
        <member name="F:Microsoft.Linq.Expressions.Compiler.LambdaCompiler._paramTypes">
            <summary>
            Argument types
            
            This list contains _all_ arguments on the underlying method builder (except for the
            "this"). There are two views on the list. First provides the raw view (shows all
            arguments), the second view provides view of the arguments which are in the original
            lambda (so first argument, which may be closure argument, is skipped in that case)
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.LambdaCompiler.CompileLambda(Microsoft.Linq.Expressions.LambdaExpression,System.Type,System.Boolean,System.Boolean,System.Reflection.MethodInfo@)">
            <summary>
            Compiler entry point
            </summary>
            <param name="lambda">LambdaExpression to compile.</param>
            <param name="method">Product of compilation</param>
            <param name="delegateType">Type of the delegate to create</param>
            <param name="emitDebugSymbols">True to emit debug symbols, false otherwise.</param>
            <param name="forceDynamic">Force dynamic method regardless of save assemblies.</param>
            <returns>The compiled delegate.</returns>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.LambdaCompiler.CompileLambda(Microsoft.Linq.Expressions.LambdaExpression,System.Reflection.Emit.TypeBuilder,System.Reflection.MethodAttributes,System.Boolean)">
            <summary>
            Creates and returns a MethodBuilder
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.LambdaCompiler.GetLambdaArgument(System.Int32)">
            <summary>
            Gets the argument slot corresponding to the parameter at the given
            index. Assumes that the method takes a certain number of prefix
            arguments, followed by the real parameters stored in Parameters
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.LambdaCompiler.EmitLambdaArgument(System.Int32)">
            <summary>
            Returns the index-th argument. This method provides access to the actual arguments
            defined on the lambda itself, and excludes the possible 0-th closure argument.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.LambdaCompiler.CreateDynamicCompiler(Microsoft.Linq.Expressions.Compiler.AnalyzedTree,Microsoft.Linq.Expressions.LambdaExpression,System.String,System.Type,System.Collections.Generic.IList{System.Type},System.Collections.Generic.IList{System.String},System.Boolean,System.Boolean)">
            <summary>
            Creates a compiler backed by dynamic method. Sometimes (when debugging is required) the dynamic
            method is actually a 'fake' dynamic method and is backed by static type created specifically for
            the one method
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.LambdaCompiler.CreateStaticCompiler(Microsoft.Linq.Expressions.Compiler.AnalyzedTree,Microsoft.Linq.Expressions.LambdaExpression,System.Reflection.Emit.TypeBuilder,System.String,System.Reflection.MethodAttributes,System.Type,System.Collections.Generic.IList{System.Type},System.Collections.Generic.IList{System.String},System.Boolean,System.Boolean)">
            <summary>
            Creates a LambdaCompiler backed by a method on a static type
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.RuleSet`1">
            <summary>
            A RuleSet is a collection of rules to apply to the objects at a DynamicSite.  Each Rule also
            includes a target that is to be called if the rules' conditions are met.
            RuleSets are all immutable.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.ExpandoObject">
            <summary>
            Simple type which implements IDynamicObject to support getting/setting/deleting members
            at runtime.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ExpandoObject.#ctor">
            <summary>
            Creates a new Expando object with no members.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ExpandoObject.GetValue(Microsoft.Scripting.ExpandoClass,System.Int32,System.Boolean)">
            <summary>
            Gets the data stored for the specified class at the specified index.  If the
            class has changed a full lookup for the slot will be performed and the correct
            value will be retrieved.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ExpandoObject.SetValue(Microsoft.Scripting.ExpandoClass,System.Int32,System.Boolean,System.Object)">
            <summary>
            Sets the data for the specified class at the specified index.  If the class has
            changed then a full look for the slot will be performed.  If the new class does
            not have the provided slot then the Expando's class will change.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ExpandoObject.DeleteValue(Microsoft.Scripting.ExpandoClass,System.Int32,System.Boolean)">
            <summary>
            Gets the data stored for the specified class at the specified index.  If the
            class has changed a full lookup for the slot will be performed and the correct
            value will be retrieved.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ExpandoObject.PromoteClassWorker(Microsoft.Scripting.ExpandoClass,Microsoft.Scripting.ExpandoClass)">
            <summary>
            Promotes the class from the old type to the new type and returns the new
            ExpandoData object.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ExpandoObject.PromoteClass(Microsoft.Scripting.ExpandoClass,Microsoft.Scripting.ExpandoClass)">
            <summary>
            Internal helper to promote a class.  Called from our RuntimeOps helper.  This
            version simply doesn't expose the ExpandoData object which is a private
            data structure.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.ExpandoObject.Class">
            <summary>
            Exposes the ExpandoClass which we've associated with this 
            Expando object.  Used for type checks in rules.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.DynamicMetaObject.BindBinaryOperationOnMember(Microsoft.Scripting.BinaryOperationOnMemberBinder,Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Binds an operation a.b (op)= c
            </summary>
            <param name="binder">Binder implementing the language semantics.</param>
            <param name="value">Meta Object representing the right-side argument.</param>
            <returns>MetaObject representing the result of the binding.</returns>
        </member>
        <member name="M:Microsoft.Scripting.DynamicMetaObject.BindBinaryOperationOnIndex(Microsoft.Scripting.BinaryOperationOnIndexBinder,Microsoft.Scripting.DynamicMetaObject[],Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Binds an operation a[i,j,k] (op)= c
            </summary>
            <param name="binder">Binder implementing the language semantics.</param>
            <param name="indexes">The array of MetaObjects representing the indexes for the index operation.</param>
            <param name="value">The MetaObject representing the right-hand value of the operation.</param>
            <returns>MetaObject representing the result of the binding.</returns>
        </member>
        <member name="M:Microsoft.Scripting.DynamicMetaObject.BindUnaryOperationOnIndex(Microsoft.Scripting.UnaryOperationOnIndexBinder,Microsoft.Scripting.DynamicMetaObject[])">
            <summary>
            Binds the unary operation performed on a result of index operation on the object.
            </summary>
            <param name="binder">The binder implementing the language semantics.</param>
            <param name="indexes">The array of MetaObject representing the indexes for the index operation.</param>
            <returns>The MetaObject representing the result of the binding.</returns>
        </member>
        <member name="M:Microsoft.Scripting.DynamicMetaObject.BindUnaryOperationOnMember(Microsoft.Scripting.UnaryOperationOnMemberBinder)">
            <summary>
            Binds the unary operation performed on a result of get member operation on the object.
            </summary>
            <param name="binder">The binder implementing the language semantics.</param>
            <returns>The MetaObject representing the result of the binding.</returns>
        </member>
        <member name="M:Microsoft.Scripting.DynamicMetaObject.GetDynamicMemberNames">
            <summary>
            Returns the enumeration of all dynamic member names.
            </summary>
            <returns>The list of dynamic members.</returns>
        </member>
        <member name="M:Microsoft.Scripting.DynamicMetaObject.GetDynamicDataMembers">
            <summary>
            Returns the enumeration of key-value pairs of all dynamic data members. Data members include members
            such as properties, fields, but not necessarily methods. The key value pair includes the member name
            and the value.
            </summary>
            <returns>The list of key-value pairs representing data member name and its value.</returns>
        </member>
        <member name="M:Microsoft.Scripting.ExpandoObject.MetaExpando.AddDynamicTestAndDefer(Microsoft.Scripting.DynamicMetaObjectBinder,Microsoft.Scripting.DynamicMetaObject[],Microsoft.Scripting.ExpandoClass,Microsoft.Scripting.ExpandoClass,Microsoft.Linq.Expressions.Expression)">
            <summary>
            Adds a dynamic test which checks if the version has changed.  The test is only necessary for
            performance as the methods will do the correct thing if called with an incorrect version.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ExpandoObject.MetaExpando.GetClassEnsureIndex(System.String,System.Boolean,Microsoft.Scripting.ExpandoClass@,System.Int32@)">
            <summary>
            Gets the class and the index associated with the given name.  Does not update the expando object.  Instead
            this returns both the original and desired new class.  A rule is created which includes the test for the
            original class, the promotion to the new class, and the set/delete based on the class post-promotion.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ExpandoObject.MetaExpando.GetLimitedSelf">
            <summary>
            Returns our Expression converted to our known LimitType
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ExpandoObject.MetaExpando.GetRestrictions">
            <summary>
            Returns a Restrictions object which includes our current restrictions merged
            with a restriction limiting our type
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.ExpandoObject.ExpandoData">
            <summary>
            Stores the class and the data associated with the class as one atomic
            pair.  This enables us to do a class check in a thread safe manner w/o
            requiring locks.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.ExpandoObject.ExpandoData.Class">
            <summary>
            the dynamically assigned class associated with the Expando object
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.ExpandoObject.ExpandoData.Data">
            <summary>
            data stored in the expando object, key names are stored in the class.
            
            Expando._data must be locked when mutating the value.  Otherwise a copy of it 
            could be made and lose values.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ExpandoObject.ExpandoData.#ctor">
            <summary>
            Constructs an empty ExpandoData object with the empty class and no data.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ExpandoObject.ExpandoData.#ctor(Microsoft.Scripting.ExpandoClass,System.Object[])">
            <summary>
            Constructs a new ExpandoData object with the specified class and data.
            </summary>
        </member>
        <member name="T:Microsoft.Runtime.CompilerServices.RuntimeOps.RuntimeVariableList">
            <summary>
            Provides a list of variables, supporing read/write of the values
            Exposed via RuntimeVariablesExpression
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.ExpressionVisitor">
            <summary>
            Base class for visiting and rewriting trees. Subclasses can override
            individual Visit methods from which they can return rewritten nodes.
            If a node is rewritten, all parent nodes will be rewritten
            automatically.
            
            TODO: rename back to ExpressionVisitor (fix the Linq test that has a copy)
            TODO: needs public API vetting
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.ExpressionVisitor.Visit``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},Microsoft.Func{``0,``0})">
            <summary>
            Visits all nodes in the collection using a specified element visitor.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="nodes">Input collection.</param>
            <param name="elementVisitor">Delegate that visits a single element.</param>
            <returns>Collection of visited nodes. Original collection is returned if no nodes were modified.</returns>
        </member>
        <member name="M:Microsoft.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.String)">
            <summary>
            Visits all of the nodes in the collection, and tries to convert each
            result back to the original type. If any conversion fails, it
            throws an error
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.ExpressionVisitor.VisitExtension(Microsoft.Linq.Expressions.Expression)">
            <summary>
            Override called for Extension nodes. This can be overriden to
            rewrite certain extension nodes. If it's not overriden, this method
            will call into Expression.Visit, which gives the node a chance to
            walk its children
            </summary>
        </member>
        <member name="T:Microsoft.Runtime.CompilerServices.RuntimeOps.MergedRuntimeVariables">
            <summary>
            Provides a list of variables, supporing read/write of the values
            Exposed via RuntimeVariablesExpression
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.AutoRuleTemplate">
            <summary>
            Handles auto-templating of rules.  There are three important actions this performs:
                1. Detects if templating is possible between two rules
                2. Re-writes a non-templated rule into templated form
                3. Extracts the constants from a non-templated rule which is compatible with a 
                    templated rule so that they can be used by the existing generated code.
                    
            Auto-templating is currently only used for serially monomorphic call sites where we
            can easily avoid code gen.  It is not used for polymorphic call sites although such
            a feature could be enabled in the future.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.AutoRuleTemplate.CopyOrCreateTemplatedRule``1(Microsoft.Runtime.CompilerServices.CallSiteRule{``0},Microsoft.Runtime.CompilerServices.CallSiteRule{``0})">
            <summary>
            The entry point into auto-rule tempating.  This consumes the monomorphic rule which is currently
            stored in the cache as well as the rule that was just produced by the binder.  
            </summary>
            <param name="from">The original rule that is currently stored in the cache.  This rule may
            or may not be a templated rule.</param>
            <param name="to">The new rule produced by a binder.</param>
        </member>
        <member name="M:Microsoft.Scripting.AutoRuleTemplate.CloneData(System.Object,System.Object[])">
            <summary>
            Clones the delegate target to create new delegate around it.
            The delegates created by the compiler are closed over the instance of Closure class.
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.Expression">
            <summary>
            Factory methods.
            </summary>
            <summary>
            Factory methods.
            </summary>
            <summary>
            Expression is the base type for all nodes in Expression Trees
            </summary>
            <summary>
            Factory methods.
            </summary>
            <summary>
            Factory methods.
            </summary>
            <summary>
            Factory methods.
            </summary>
            <summary>
            Factory methods.
            TODO: review which of these overloads we actually need
            </summary>
            <summary>
            Factory methods
            </summary>
            <summary>
            Factory methods.
            </summary>
            <summary>
            Factory methods.
            </summary>
            <summary>
            Factory methods.
            </summary>
            <summary>
            Factory methods.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Expression.PositionalArg(System.Int32)">
            <summary>
            Returns a new PositionalArgumentInfo that represents a positional argument in the dynamic binding process.
            </summary>
            <param name="position">A position of the argument in the call signature.</param>
            <returns>The new PositionalArgumentInfo.</returns>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Expression.NamedArg(System.String)">
            <summary>
            Returns a new NamedArgumentInfo that represents a named argument in the dynamic binding process.
            </summary>
            <param name="name">The name of the argument at the call site.</param>
            <returns>The new NamedArgumentInfo.</returns>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Expression.ByRefArgument(System.Int32)">
            <summary>
            Returns a new PositionalArgumentInfo that represents a positional by ref argument in the dynamic binding process.
            </summary>
            <param name="position">A position of the argument in the call signature.</param>
            <returns>The new PositionalArgumentInfo.</returns>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Expression.NewArrayInit(System.Type,Microsoft.Linq.Expressions.Expression[])">
            <summary>
            Creates a new array expression of the specified type from the provided initializers.
            </summary>
            <param name="type">A Type that represents the element type of the array.</param>
            <param name="initializers">The expressions used to create the array elements.</param>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{Microsoft.Linq.Expressions.Expression})">
            <summary>
            Creates a new array expression of the specified type from the provided initializers.
            </summary>
            <param name="type">A Type that represents the element type of the array.</param>
            <param name="initializers">The expressions used to create the array elements.</param>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{Microsoft.Linq.Expressions.Expression})">
            <summary>
            Creates a list of expressions whose value is the value of the last expression.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Expression.Reduce">
            <summary>
            Reduces this node to a simpler expression. If CanReduce returns
            true, this should return a valid expression. This method is
            allowed to return another node which itself must be reduced.
            </summary>
            <returns>the reduced expression</returns>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Expression.VisitChildren(Microsoft.Linq.Expressions.ExpressionVisitor)">
            <summary>
            Override this to provide logic to walk the node's children. A
            typical implementation will call visitor.Visit on each of its
            children, and if any of them change, should return a new copy of
            itself with the modified children.
            
            The default implementation will reduce the node and then walk it
            This will throw an exception if the node is not reducible
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Expression.ReduceAndCheck">
            <summary>
            Reduces this node to a simpler expression. If CanReduce returns
            true, this should return a valid expression. This method is
            allowed to return another node which itself must be reduced.
            
            Unlike Reduce, this method checks that the reduced node satisfies
            certain invaraints.
            </summary>
            <returns>the reduced expression</returns>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Expression.ReduceExtensions">
            <summary>
            Reduces the expression to a known node type (i.e. not an Extension node)
            or simply returns the expression if it is already a known type.
            </summary>
            <returns>the reduced expression</returns>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Expression.ReturnReadOnly``1(System.Collections.Generic.IList{``0}@)">
            <summary>
            Helper used for ensuring we only return 1 instance of a ReadOnlyCollection of T.
            
            This is called from various methods where we internally hold onto an IList of T
            or a ROC of T.  We check to see if we've already returned a ROC of T and if so
            simply return the other one.  Otherwise we do a thread-safe replacement of hte
            list w/ a ROC which wraps it.
            
            Ultimately this saves us from having to allocate a ReadOnlyCollection for our
            data types because the compiler is capable of going directly to the IList of T.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Expression.ReturnReadOnly(Microsoft.Linq.Expressions.IArgumentProvider,System.Object@)">
            <summary>
            Helper used for ensuring we only return 1 instance of a ReadOnlyCollection of T.
            
            This is similar to the ReturnReadOnly of T. This version supports nodes which hold 
            onto multiple Expressions where one is typed to object.  That object field holds either
            an expression or a ReadOnlyCollection of Expressions.  When it holds a ReadOnlyCollection
            the IList which backs it is a ListArgumentProvider which uses the Expression which
            implements IArgumentProvider to get 2nd and additional values.  The ListArgumentProvider 
            continues to hold onto the 1st expression.  
            
            This enables users to get the ReadOnlyCollection w/o it consuming more memory than if 
            it was just an array.  Meanwhile The DLR internally avoids accessing  which would force 
            the ROC to be created resulting in a typical memory savings.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Expression.ReturnObject``1(System.Object)">
            <summary>
            Helper which is used for specialized subtypes which use ReturnReadOnly(ref object, ...). 
            This is the reverse version of ReturnReadOnly which takes an IArgumentProvider.
            
            This is used to return the 1st argument.  The 1st argument is typed as object and either
            contains a ReadOnlyCollection or the Expression.  We check for the Expression and if it's
            present we return that, otherwise we return the 1st element of the ReadOnlyCollection.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Expression.GetDelegateType(System.Type[])">
            <summary>
            Gets a Func or Action corresponding to the given type arguments. If
            no Func or Action is large enough, it will generate a custom
            delegate type.
            
            As with Func, the last argument is the return type. It can be set
            to System.Void to produce a an Action.
            </summary>
            <param name="typeArgs">The type arguments of the delegate.</param>
            <returns>The delegate type.</returns>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Expression.TypeEqual(Microsoft.Linq.Expressions.Expression,System.Type)">
            <summary>
            Creates an Expression that compares run-time type identity. It is
            roughly equivalent to a tree that does this:
                obj != null &amp;&amp; obj.GetType() == type
                
            If you want to check for "null" use Expression.Equal
            </summary>
            <param name="expression">The operand.</param>
            <param name="type">The type to check for at run-time.</param>
            <returns>A new Expression that performs a type equality check.</returns>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Expression.Assign(Microsoft.Linq.Expressions.Expression,Microsoft.Linq.Expressions.Expression)">
            <summary>
            Performs an assignment variable = value
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Expression.CanReduce">
            <summary>
            Indicates that the node can be reduced to a simpler node. If this 
            returns true, Reduce() can be called to produce the reduced form.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DelegateHelpers.MakeDelegateType(System.Type[])">
            <summary>
            Finds a delegate type using the types in the array. 
            We use the cache to avoid copying the array, and to cache the
            created delegate type
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DelegateHelpers.MakeCallSiteDelegate(System.Collections.ObjectModel.ReadOnlyCollection{Microsoft.Linq.Expressions.Expression},System.Type)">
            <summary>
            Finds a delegate type for a CallSite using the types in the ReadOnlyCollection of Expression. 
            
            We take the ROC of Expression explicitly to avoid allocating memory (an array of types) on
            lookup of delegate types.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DelegateHelpers.MakeDeferredSiteDelegate(Microsoft.Scripting.DynamicMetaObject[],System.Type)">
            <summary>
            Finds a delegate type for a CallSite using the MetaObject array. 
            
            We take the array of MetaObject explicitly to avoid allocating memory (an array of types) on
            lookup of delegate types.
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.IArgumentProvider">
            <summary>
            Provides an internal interface for accessing the arguments that multiple tree
            nodes (DynamicExpression, ElementInit, MethodCallExpression, InvocationExpression, NewExpression,
            and InexExpression).
            
            This enables two optimizations which reduce the size of the trees.  The first is it enables
            the nodes to hold onto an IList of T instead of a ReadOnlyCollection.  This saves the cost
            of allocating the ReadOnlyCollection for each node.  The second is that it enables specialized
            subclasses to be created which hold onto a specific number of arguments.  For example Block2,
            Block3, Block4.  These nodes can therefore avoid allocating both a ReadOnlyCollection and an
            array for storing their elements saving 32 bytes per node.
            
            Meanwhile the nodes can continue to expose the original LINQ properties of ReadOnlyCollections.  They
            do this by re-using 1 field for storing both the array or an element that would normally be stored
            in the array.  
            
            For the array case the collection is typed to IList of T instead of ReadOnlyCollection of T.
            When the node is initially constructed it is an array.  When the compiler accesses the members it
            uses this interface.  If a user accesses the members the array is promoted to a ReadOnlyCollection.
            
            For the object case we store the 1st argument in a field typed to object and when the node is initially
            constructed this holds directly onto the Expression.  When the compiler accesses the members
            it again uses this interface and the accessor for the 1st argument uses Expression.ReturnObject to
            return the object which handles the Expression or ReadOnlyCollection case.  When the user accesses
            the ReadOnlyCollection then the object field is updated to hold directly onto the ReadOnlyCollection.
            
            It is important that the Expressions consistently return the same ReadOnlyCollection otherwise the
            re-writer will be broken and it would be a breaking change from LINQ v1.  The problem is that currently
            users can rely on object identity to tell if the node has changed.  Storing the ROC in an overloaded
            field enables us to both reduce memory usage as well as maintain compatibility and an easy to use external
            API.
            </summary>
        </member>
        <member name="T:Microsoft.Runtime.CompilerServices.CallSiteBinder">
            <summary>
            Class responsible for binding dynamic operations on the dynamic site.
            </summary>
        </member>
        <member name="M:Microsoft.Runtime.CompilerServices.CallSiteBinder.Bind(System.Object[],System.Collections.ObjectModel.ReadOnlyCollection{Microsoft.Linq.Expressions.ParameterExpression},Microsoft.Linq.Expressions.LabelTarget)">
            <summary>
            The bind call to produce the binding.
            </summary>
            <param name="args">Array of arguments to the call</param>
            <param name="parameters">Array of ParameterExpressions that represent to parameters of the call site</param>
            <param name="returnLabel">LabelTarget used to return the result of the call site</param>
            <returns>
            An Expression that performs tests on the arguments, and
            returns a result if the test is valid. If the tests fail, Bind
            will be called again to produce a new Expression for the new
            argument types
            </returns>
        </member>
        <member name="P:Microsoft.Runtime.CompilerServices.CallSiteBinder.CacheIdentity">
            <summary>
            Key used for the DLR caching
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresArrayIndex``1(System.Collections.Generic.IList{``0},System.Int32,System.String)">
            <summary>
            Requires the specified index to point inside the array.
            </summary>
            <exception cref="T:System.ArgumentNullException">Array is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Index is outside the array.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresArrayInsertIndex``1(System.Collections.Generic.IList{``0},System.Int32,System.String)">
            <summary>
            Requires the specified index to point inside the array or at the end
            </summary>
            <exception cref="T:System.ArgumentNullException">Array is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Index is outside the array.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresArrayRange``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,System.String,System.String)">
            <summary>
            Requires the range [offset, offset + count] to be a subset of [0, array.Count].
            </summary>
            <exception cref="T:System.ArgumentNullException">Array is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Offset or count are out of range.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresListRange(System.Collections.IList,System.Int32,System.Int32,System.String,System.String)">
            <summary>
            Requires the range [offset, offset + count] to be a subset of [0, array.Count].
            </summary>
            <exception cref="T:System.ArgumentNullException">Array is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Offset or count are out of range.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresArrayRange(System.String,System.Int32,System.Int32,System.String,System.String)">
            <summary>
            Requires the range [offset, offset + count] to be a subset of [0, array.Count].
            </summary>
            <exception cref="T:System.ArgumentNullException">String is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Offset or count are out of range.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresNotNullItems``1(System.Collections.Generic.IList{``0},System.String)">
            <summary>
            Requires the array and all its items to be non-null.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.CacheDict`2">
            <summary>
            Provides a dictionary-like object used for caches which holds onto a maximum
            number of elements specified at construction time.
            
            This class is not thread safe.
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.SymbolDocumentInfo">
            <summary>
            Stores information needed to emit debugging symbol information for a
            source file, in particular the file name and unique language identifier
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.SymbolDocumentInfo.FileName">
            <summary>
            The source file name
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.SymbolDocumentInfo.Language">
            <summary>
            Returns the language's unique identifier, if any
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.SymbolDocumentInfo.LanguageVendor">
            <summary>
            Returns the language vendor's unique identifier, if any
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.SymbolDocumentInfo.DocumentType">
            <summary>
            Returns the document type's unique identifier, if any
            Defaults to the guid for a text file
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.BindingRestrictions.AddRestrictions(Microsoft.Scripting.BindingRestrictions.Restriction[],System.Collections.Generic.List{Microsoft.Scripting.BindingRestrictions.Restriction})">
            <summary>
            Adds unique restrictions and doesn't add restrictions which are alerady present
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.BindingRestrictions.CreateTypeRestriction(Microsoft.Linq.Expressions.Expression,System.Type)">
            <summary>
            Creates one type identity test 
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.Strings">
            <summary>
               Strongly-typed and parameterized string factory.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.UserDefinedOperatorMustBeStatic(System.Object)">
            <summary>
            A string like  "User-defined operator method '{0}' must be static."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.UserDefinedOperatorMustNotBeVoid(System.Object)">
            <summary>
            A string like  "User-defined operator method '{0}' must not be void."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.CoercionOperatorNotDefined(System.Object,System.Object)">
            <summary>
            A string like  "No coercion operator is defined between types '{0}' and '{1}'."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.UnaryOperatorNotDefined(System.Object,System.Object)">
            <summary>
            A string like  "The unary operator {0} is not defined for the type '{1}'."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.BinaryOperatorNotDefined(System.Object,System.Object,System.Object)">
            <summary>
            A string like  "The binary operator {0} is not defined for the types '{1}' and '{2}'."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.OperandTypesDoNotMatchParameters(System.Object,System.Object)">
            <summary>
            A string like  "The operands for operator '{0}' do not match the parameters of method '{1}'."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.OverloadOperatorTypeDoesNotMatchConversionType(System.Object,System.Object)">
            <summary>
            A string like  "The return type of overload method for operator '{0}' does not match the parameter type of conversion method '{1}'."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.CannotAutoInitializeValueTypeElementThroughProperty(System.Object)">
            <summary>
            A string like  "Cannot auto initialize elements of value type through property '{0}', use assignment instead"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.CannotAutoInitializeValueTypeMemberThroughProperty(System.Object)">
            <summary>
            A string like  "Cannot auto initialize members of value type through property '{0}', use assignment instead"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.IncorrectTypeForTypeAs(System.Object)">
            <summary>
            A string like  "The type used in TypeAs Expression must be of reference or nullable type, {0} is neither"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.ExpressionTypeCannotInitializeArrayType(System.Object,System.Object)">
            <summary>
            A string like  "An expression of type '{0}' cannot be used to initialize an array of type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.ExpressionTypeDoesNotMatchConstructorParameter(System.Object,System.Object)">
            <summary>
            A string like  "Expression of type '{0}' cannot be used for constructor parameter of type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.ArgumentTypeDoesNotMatchMember(System.Object,System.Object)">
            <summary>
            A string like  " Argument type '{0}' does not match the corresponding member type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.ArgumentMemberNotDeclOnType(System.Object,System.Object)">
            <summary>
            A string like  " The member '{0}' is not declared on type '{1}' being created"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.ExpressionTypeDoesNotMatchMethodParameter(System.Object,System.Object,System.Object)">
            <summary>
            A string like  "Expression of type '{0}' cannot be used for parameter of type '{1}' of method '{2}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.ExpressionTypeDoesNotMatchParameter(System.Object,System.Object)">
            <summary>
            A string like  "Expression of type '{0}' cannot be used for parameter of type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.ExpressionTypeDoesNotMatchReturn(System.Object,System.Object)">
            <summary>
            A string like  "Expression of type '{0}' cannot be used for return type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.ExpressionTypeDoesNotMatchAssignment(System.Object,System.Object)">
            <summary>
            A string like  "Expression of type '{0}' cannot be used for assignment to type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.ExpressionTypeDoesNotMatchLabel(System.Object,System.Object)">
            <summary>
            A string like  "Expression of type '{0}' cannot be used for label of type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.ExpressionTypeNotInvocable(System.Object)">
            <summary>
            A string like  "Expression of type '{0}' cannot be invoked"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.FieldNotDefinedForType(System.Object,System.Object)">
            <summary>
            A string like  "Field '{0}' is not defined for type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.InstanceFieldNotDefinedForType(System.Object,System.Object)">
            <summary>
            A string like  "Instance field '{0}' is not defined for type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.FieldInfoNotDefinedForType(System.Object,System.Object,System.Object)">
            <summary>
            A string like  "Field '{0}.{1}' is not defined for type '{2}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.IncorrectNumberOfMethodCallArguments(System.Object)">
            <summary>
            A string like  "Incorrect number of arguments supplied for call to method '{0}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.MemberNotFieldOrProperty(System.Object)">
            <summary>
            A string like  "Member '{0}' not field or property"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.MethodContainsGenericParameters(System.Object)">
            <summary>
            A string like  "Method {0} contains generic parameters"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.MethodIsGeneric(System.Object)">
            <summary>
            A string like  "Method {0} is a generic method definition"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.MethodNotPropertyAccessor(System.Object,System.Object)">
            <summary>
            A string like  "The method '{0}.{1}' is not a property accessor"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.PropertyDoesNotHaveGetter(System.Object)">
            <summary>
            A string like  "The property '{0}' has no 'get' accessor"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.PropertyDoesNotHaveSetter(System.Object)">
            <summary>
            A string like  "The property '{0}' has no 'set' accessor"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.PropertyDoesNotHaveAccessor(System.Object)">
            <summary>
            A string like  "The property '{0}' has no 'get' or 'set' accessors"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.NotAMemberOfType(System.Object,System.Object)">
            <summary>
            A string like  "'{0}' is not a member of type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.OperatorNotImplementedForType(System.Object,System.Object)">
            <summary>
            A string like  "The operator '{0}' is not implemented for type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.ParameterExpressionNotValidAsDelegate(System.Object,System.Object)">
            <summary>
            A string like  "ParameterExpression of type '{0}' cannot be used for delegate parameter of type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.PropertyNotDefinedForType(System.Object,System.Object)">
            <summary>
            A string like  "Property '{0}' is not defined for type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.InstancePropertyNotDefinedForType(System.Object,System.Object)">
            <summary>
            A string like  "Instance property '{0}' is not defined for type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.PropertyInfoNotDefinedForType(System.Object,System.Object,System.Object)">
            <summary>
            A string like  "Property '{0}.{1}' is not defined for type '{2}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.MethodNotDefinedForType(System.Object,System.Object)">
            <summary>
            A string like  "Method '{0}' is not defined for type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.TypeContainsGenericParameters(System.Object)">
            <summary>
            A string like  "Type {0} contains generic parameters"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.TypeIsGeneric(System.Object)">
            <summary>
            A string like  "Type {0} is a generic type definition"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.TypeMissingDefaultConstructor(System.Object)">
            <summary>
            A string like  "Type '{0}' does not have a default constructor"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.ElementInitializerMethodNoRefOutParam(System.Object,System.Object)">
            <summary>
            A string like  "Parameter '{0}' of element initializer method '{1}' must not be a pass by reference parameter"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.TypeNotIEnumerable(System.Object)">
            <summary>
            A string like  "Type '{0}' is not IEnumerable"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.TypeParameterIsNotDelegate(System.Object)">
            <summary>
            A string like  "Type parameter is {0}. Expected a delegate."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.InvalidCast(System.Object,System.Object)">
            <summary>
            A string like  "Cannot cast from type '{0}' to type '{1}"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.UnhandledBinary(System.Object)">
            <summary>
            A string like  "Unhandled binary: {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.UnhandledBindingType(System.Object)">
            <summary>
            A string like  "Unhandled Binding Type: {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.UnhandledConvert(System.Object)">
            <summary>
            A string like  "Unhandled convert: {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.UnhandledExpressionType(System.Object)">
            <summary>
            A string like  "Unhandled Expression Type: {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.UnhandledUnary(System.Object)">
            <summary>
            A string like  "Unhandled unary: {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.UserDefinedOpMustHaveConsistentTypes(System.Object,System.Object)">
            <summary>
            A string like  "The user-defined operator method '{1}' for operator '{0}' must have identical parameter and return types."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.UserDefinedOpMustHaveValidReturnType(System.Object,System.Object)">
            <summary>
            A string like  "The user-defined operator method '{1}' for operator '{0}' must return the same type as its parameter or a derived type."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.LogicalOperatorMustHaveBooleanOperators(System.Object,System.Object)">
            <summary>
            A string like  "The user-defined operator method '{1}' for operator '{0}' must have associated boolean True and False operators."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.MethodDoesNotExistOnType(System.Object,System.Object)">
            <summary>
            A string like  "No method '{0}' exists on type '{1}'."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.MethodWithArgsDoesNotExistOnType(System.Object,System.Object)">
            <summary>
            A string like  "No method '{0}' on type '{1}' is compatible with the supplied arguments."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.MethodWithMoreThanOneMatch(System.Object,System.Object)">
            <summary>
            A string like  "More than one method '{0}' on type '{1}' is compatible with the supplied arguments."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.InvalidOperation(System.Object)">
            <summary>
            A string like  "Invalid operation: '{0}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.OutOfRange(System.Object,System.Object)">
            <summary>
            A string like  "{0} must be greater than or equal to {1}"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.LabelTargetAlreadyDefined(System.Object)">
            <summary>
            A string like  "Cannot redefine label '{0}' in an inner block."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.LabelTargetUndefined(System.Object)">
            <summary>
            A string like  "Cannot jump to to undefined label '{0}'."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.AmbiguousJump(System.Object)">
            <summary>
            A string like  "Cannot jump to ambiguous label '{0}'."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.InvalidLvalue(System.Object)">
            <summary>
            A string like  "Invalid lvalue for assignment: {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.InvalidMemberType(System.Object)">
            <summary>
            A string like  "Invalid member type: {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.UnknownLiftType(System.Object)">
            <summary>
            A string like  "unknown lift type: '{0}'."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.IllegalNewGenericParams(System.Object)">
            <summary>
            A string like  "Cannot create instance of {0} because it contains generic parameters"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.UndefinedVariable(System.Object,System.Object,System.Object)">
            <summary>
            A string like  "variable '{0}' of type '{1}' referenced from scope '{2}', but it is not defined"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.CannotCloseOverByRef(System.Object,System.Object)">
            <summary>
            A string like  "Cannot close over byref parameter '{0}' referenced in lambda '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.UnexpectedVarArgsCall(System.Object)">
            <summary>
            A string like  "Unexpected VarArgs call to method '{0}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.MustRewriteToSameType(System.Object,System.Object,System.Object)">
            <summary>
            A string like  "When called from '{0}', rewriting a node of type '{1}' should return a non-null value of the same type. Alternatively, override '{2}' and change it to not visit children of this type."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.OwningTeam">
            <summary>
            A string like  "DLinq"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.MethodPreconditionViolated">
            <summary>
            A string like  "Method precondition violated"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.InvalidArgumentValue">
            <summary>
            A string like  "Invalid argument value"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.NonEmptyStringRequired">
            <summary>
            A string like  "Non-empty string required"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.NonEmptyCollectionRequired">
            <summary>
            A string like  "Non-empty collection required"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.MustBePositive">
            <summary>
            A string like  "must be &gt;= 0"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ReducibleMustOverrideReduce">
            <summary>
            A string like  "reducible nodes must override Expression.Reduce()"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.MustReduceToDifferent">
            <summary>
            A string like  "node cannot reduce to itself or null"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ReducedNotCompatible">
            <summary>
            A string like  "cannot assign from the reduced node type to the original node type"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.SetterHasNoParams">
            <summary>
            A string like  "Setter must have parameters."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.PropertyCannotHaveRefType">
            <summary>
            A string like  "Property cannot have a managed pointer type."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.IndexesOfSetGetMustMatch">
            <summary>
            A string like  "Indexing parameters of getter and setter must match."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.AccessorsCannotHaveVarArgs">
            <summary>
            A string like  "Accessor method should not have VarArgs."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.AccessorsCannotHaveByRefArgs">
            <summary>
            A string like  "Accessor indexes cannot be passed ByRef."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.BoundsCannotBeLessThanOne">
            <summary>
            A string like  "Bounds count cannot be less than 1"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ValueMustBeInt">
            <summary>
            A string like  "Value must be int"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.OnlyDefaultIsAllowed">
            <summary>
            A string like  "Only one default clause allowed"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.CaseValuesMustBeUnique">
            <summary>
            A string like  "Case values must be unique"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.TypeMustNotBeByRef">
            <summary>
            A string like  "type must not be ByRef"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.VariableMustNotBeByRef">
            <summary>
            A string like  "variable must not be ByRef"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.TypeDoesNotHaveConstructorForTheSignature">
            <summary>
            A string like  "Type doesn't have constructor with a given signature"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.TypeDoesNotHaveMethodForName">
            <summary>
            A string like  "Type doesn't have a method with a given name."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.TypeDoesNotHaveMethodForNameSignature">
            <summary>
            A string like  "Type doesn't have a method with a given name and signature."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.CountCannotBeNegative">
            <summary>
            A string like  "Count must be non-negative."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ArrayTypeMustBeArray">
            <summary>
            A string like  "arrayType must be an array type"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.SetterMustBeVoid">
            <summary>
            A string like  "Setter should have void type."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.PropertyTyepMustMatchSetter">
            <summary>
            A string like  "Property type must match the value type of setter"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.BothAccessorsMustBeStatic">
            <summary>
            A string like  "Both accessors must be static."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.OnlyStaticFieldsHaveNullInstance">
            <summary>
            A string like  "Static field requires null instance, non-static field requires non-null instance."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.OnlyStaticPropertiesHaveNullInstance">
            <summary>
            A string like  "Static property requires null instance, non-static property requires non-null instance."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.OnlyStaticMethodsHaveNullInstance">
            <summary>
            A string like  "Static method requires null instance, non-static method requires non-null instance."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.PropertyTypeCannotBeVoid">
            <summary>
            A string like  "Property cannot have a void type."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.InvalidUnboxType">
            <summary>
            A string like  "Can only unbox from an object or interface type to a value type."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ExpressionMustBeReadable">
            <summary>
            A string like  "Expression must be readable"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ExpressionMustBeWriteable">
            <summary>
            A string like  "Expression must be writeable"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ArgumentMustBeException">
            <summary>
            A string like  "Argument must be exception"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.MustBeReducible">
            <summary>
            A string like  "must be reducible node"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.InvalidTypeBuilder">
            <summary>
            A string like  "TypeBuilder does not have a valid ModuleBuilder"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.TypeMustBeDerivedFromSystemDelegate">
            <summary>
            A string like  "Type must be derived from System.Delegate"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ArgumentTypeCannotBeVoid">
            <summary>
            A string like  "Argument type cannot be void"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.LabelMustBeVoidOrHaveExpression">
            <summary>
            A string like  "Label type must be System.Void if an expression is not supplied"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.LabelTypeMustBeVoid">
            <summary>
            A string like  "Type must be System.Void for this label argument"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.StartEndMustBeOrdered">
            <summary>
            A string like  "Start and End must be well ordered"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.FaultCannotHaveCatchOrFinally">
            <summary>
            A string like  "fault cannot be used with catch or finally clauses"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.TryMustHaveCatchFinallyOrFault">
            <summary>
            A string like  "try must have at least one catch, finally, or fault clause"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.BodyOfCatchMustHaveSameTypeAsBodyOfTry">
            <summary>
            A string like  "Body of catch must have the same type as body of try."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ConversionIsNotSupportedForArithmeticTypes">
            <summary>
            A string like  "Conversion is not supported for arithmetic types without operator overloading."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ArgumentMustBeArray">
            <summary>
            A string like  "Argument must be array"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ArgumentMustBeBoolean">
            <summary>
            A string like  "Argument must be boolean"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ArgumentMustBeFieldInfoOrPropertInfo">
            <summary>
            A string like  "Argument must be either a FieldInfo or PropertyInfo"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ArgumentMustBeFieldInfoOrPropertInfoOrMethod">
            <summary>
            A string like  "Argument must be either a FieldInfo, PropertyInfo or MethodInfo"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ArgumentMustBeInstanceMember">
            <summary>
            A string like  "Argument must be an instance member"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ArgumentMustBeInteger">
            <summary>
            A string like  "Argument must be of an integer type"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ArgumentMustBeArrayIndexType">
            <summary>
            A string like  "Argument for array index must be of type Int32"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ArgumentMustBeSingleDimensionalArrayType">
            <summary>
            A string like  "Argument must be single dimensional array type"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ArgumentTypesMustMatch">
            <summary>
            A string like  "Argument types do not match"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.CoalesceUsedOnNonNullType">
            <summary>
            A string like  "Coalesce used with type that cannot be null"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.IncorrectNumberOfIndexes">
            <summary>
            A string like  "Incorrect number of indexes"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.IncorrectNumberOfLambdaArguments">
            <summary>
            A string like  "Incorrect number of arguments supplied for lambda invocation"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.IncorrectNumberOfLambdaDeclarationParameters">
            <summary>
            A string like  "Incorrect number of parameters supplied for lambda declaration"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.IncorrectNumberOfConstructorArguments">
            <summary>
            A string like  "Incorrect number of arguments for constructor"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.IncorrectNumberOfMembersForGivenConstructor">
            <summary>
            A string like  " Incorrect number of members for constructor"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.IncorrectNumberOfArgumentsForMembers">
            <summary>
            A string like  "Incorrect number of arguments for the given members "
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.LambdaTypeMustBeDerivedFromSystemDelegate">
            <summary>
            A string like  "Lambda type parameter must be derived from System.Delegate"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ListInitializerWithZeroMembers">
            <summary>
            A string like  "List initializers must contain at least one initializer"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ElementInitializerMethodNotAdd">
            <summary>
            A string like  "Element initializer method must be named 'Add'"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ElementInitializerMethodWithZeroArgs">
            <summary>
            A string like  "Element initializer method must have at least 1 parameter"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ElementInitializerMethodStatic">
            <summary>
            A string like  "Element initializer method must be an instance method"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.UnexpectedCoalesceOperator">
            <summary>
            A string like  "Unexpected coalesce operator."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.UnhandledBinding">
            <summary>
            A string like  "Unhandled binding "
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.UnknownBindingType">
            <summary>
            A string like  "Unknown binding type"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.IncorrectNumberOfTypeArgsForFunc">
            <summary>
            A string like  "An incorrect number of type args were specified for the declaration of a Func type."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.IncorrectNumberOfTypeArgsForAction">
            <summary>
            A string like  "An incorrect number of type args were specified for the declaration of an Action type."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ArgumentCannotBeOfTypeVoid">
            <summary>
            A string like  "Argument type cannot be System.Void."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.NoOrInvalidRuleProduced">
            <summary>
            A string like  "No or Invalid rule produced"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.FirstArgumentMustBeCallSite">
            <summary>
            A string like  "First argument of delegate must be CallSite"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.BindingCannotBeNull">
            <summary>
            A string like  "Bind cannot return null."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.BadDelegateData">
            <summary>
            A string like  "Bad data bound to delegate."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.QueueEmpty">
            <summary>
            A string like  "Queue empty."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ControlCannotLeaveFinally">
            <summary>
            A string like  "Control cannot leave a finally block."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ControlCannotLeaveFilterTest">
            <summary>
            A string like  "Control cannot leave a filter test."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ControlCannotEnterTry">
            <summary>
            A string like  "Control cannot enter a try block."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ControlCannotEnterExpression">
            <summary>
            A string like  "Control cannot enter an expression--only statements can be jumped into."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ExtensionNotReduced">
            <summary>
            A string like  "Extension should have been reduced."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.RtConstRequiresBundDelegate">
            <summary>
            A string like  "Runtime constants require a bound delegate."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.InvalidOutputDir">
            <summary>
            A string like  "Invalid output directory."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.InvalidAsmNameOrExtension">
            <summary>
            A string like  "Invalid assembly name or file extension."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.StackChangedWhileEnumerationg">
            <summary>
            A string like  "Stack changed while enumerating."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.CollectionReadOnly">
            <summary>
            A string like  "Collection is read-only."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.RethrowRequiresCatch">
            <summary>
            A string like  "Rethrow statement is valid only inside a Catch block."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.TryNotAllowedInFilter">
            <summary>
            A string like  "Try expression is not allowed inside a filter body."
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.Error">
            <summary>
               Strongly-typed and parameterized exception factory.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.StartEndMustBeOrdered">
            <summary>
            ArgumentException with message like "Start and End must be well ordered"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.FaultCannotHaveCatchOrFinally">
            <summary>
            ArgumentException with message like "fault cannot be used with catch or finally clauses"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.TryMustHaveCatchFinallyOrFault">
            <summary>
            ArgumentException with message like "try must have at least one catch, finally, or fault clause"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.BodyOfCatchMustHaveSameTypeAsBodyOfTry">
            <summary>
            ArgumentException with message like "Body of catch must have the same type as body of try."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.UserDefinedOperatorMustBeStatic(System.Object)">
            <summary>
            ArgumentException with message like "User-defined operator method '{0}' must be static."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.UserDefinedOperatorMustNotBeVoid(System.Object)">
            <summary>
            ArgumentException with message like "User-defined operator method '{0}' must not be void."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.CoercionOperatorNotDefined(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "No coercion operator is defined between types '{0}' and '{1}'."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.UnaryOperatorNotDefined(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "The unary operator {0} is not defined for the type '{1}'."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.BinaryOperatorNotDefined(System.Object,System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "The binary operator {0} is not defined for the types '{1}' and '{2}'."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.OperandTypesDoNotMatchParameters(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "The operands for operator '{0}' do not match the parameters of method '{1}'."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.OverloadOperatorTypeDoesNotMatchConversionType(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "The return type of overload method for operator '{0}' does not match the parameter type of conversion method '{1}'."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ConversionIsNotSupportedForArithmeticTypes">
            <summary>
            InvalidOperationException with message like "Conversion is not supported for arithmetic types without operator overloading."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ArgumentMustBeArray">
            <summary>
            ArgumentException with message like "Argument must be array"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ArgumentMustBeBoolean">
            <summary>
            ArgumentException with message like "Argument must be boolean"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ArgumentMustBeFieldInfoOrPropertInfo">
            <summary>
            ArgumentException with message like "Argument must be either a FieldInfo or PropertyInfo"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ArgumentMustBeFieldInfoOrPropertInfoOrMethod">
            <summary>
            ArgumentException with message like "Argument must be either a FieldInfo, PropertyInfo or MethodInfo"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ArgumentMustBeInstanceMember">
            <summary>
            ArgumentException with message like "Argument must be an instance member"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ArgumentMustBeInteger">
            <summary>
            ArgumentException with message like "Argument must be of an integer type"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ArgumentMustBeArrayIndexType">
            <summary>
            ArgumentException with message like "Argument for array index must be of type Int32"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ArgumentMustBeSingleDimensionalArrayType">
            <summary>
            ArgumentException with message like "Argument must be single dimensional array type"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ArgumentTypesMustMatch">
            <summary>
            ArgumentException with message like "Argument types do not match"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.CannotAutoInitializeValueTypeElementThroughProperty(System.Object)">
            <summary>
            InvalidOperationException with message like "Cannot auto initialize elements of value type through property '{0}', use assignment instead"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.CannotAutoInitializeValueTypeMemberThroughProperty(System.Object)">
            <summary>
            InvalidOperationException with message like "Cannot auto initialize members of value type through property '{0}', use assignment instead"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.IncorrectTypeForTypeAs(System.Object)">
            <summary>
            ArgumentException with message like "The type used in TypeAs Expression must be of reference or nullable type, {0} is neither"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.CoalesceUsedOnNonNullType">
            <summary>
            InvalidOperationException with message like "Coalesce used with type that cannot be null"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ExpressionTypeCannotInitializeArrayType(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "An expression of type '{0}' cannot be used to initialize an array of type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ExpressionTypeDoesNotMatchConstructorParameter(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Expression of type '{0}' cannot be used for constructor parameter of type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ArgumentTypeDoesNotMatchMember(System.Object,System.Object)">
            <summary>
            ArgumentException with message like " Argument type '{0}' does not match the corresponding member type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ArgumentMemberNotDeclOnType(System.Object,System.Object)">
            <summary>
            ArgumentException with message like " The member '{0}' is not declared on type '{1}' being created"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ExpressionTypeDoesNotMatchMethodParameter(System.Object,System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Expression of type '{0}' cannot be used for parameter of type '{1}' of method '{2}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ExpressionTypeDoesNotMatchParameter(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Expression of type '{0}' cannot be used for parameter of type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ExpressionTypeDoesNotMatchReturn(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Expression of type '{0}' cannot be used for return type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ExpressionTypeDoesNotMatchAssignment(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Expression of type '{0}' cannot be used for assignment to type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ExpressionTypeDoesNotMatchLabel(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Expression of type '{0}' cannot be used for label of type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ExpressionTypeNotInvocable(System.Object)">
            <summary>
            ArgumentException with message like "Expression of type '{0}' cannot be invoked"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.FieldNotDefinedForType(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Field '{0}' is not defined for type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.InstanceFieldNotDefinedForType(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Instance field '{0}' is not defined for type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.FieldInfoNotDefinedForType(System.Object,System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Field '{0}.{1}' is not defined for type '{2}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.IncorrectNumberOfIndexes">
            <summary>
            ArgumentException with message like "Incorrect number of indexes"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.IncorrectNumberOfLambdaArguments">
            <summary>
            InvalidOperationException with message like "Incorrect number of arguments supplied for lambda invocation"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.IncorrectNumberOfLambdaDeclarationParameters">
            <summary>
            ArgumentException with message like "Incorrect number of parameters supplied for lambda declaration"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.IncorrectNumberOfMethodCallArguments(System.Object)">
            <summary>
            ArgumentException with message like "Incorrect number of arguments supplied for call to method '{0}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.IncorrectNumberOfConstructorArguments">
            <summary>
            ArgumentException with message like "Incorrect number of arguments for constructor"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.IncorrectNumberOfMembersForGivenConstructor">
            <summary>
            ArgumentException with message like " Incorrect number of members for constructor"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.IncorrectNumberOfArgumentsForMembers">
            <summary>
            ArgumentException with message like "Incorrect number of arguments for the given members "
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.LambdaTypeMustBeDerivedFromSystemDelegate">
            <summary>
            ArgumentException with message like "Lambda type parameter must be derived from System.Delegate"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.MemberNotFieldOrProperty(System.Object)">
            <summary>
            ArgumentException with message like "Member '{0}' not field or property"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.MethodContainsGenericParameters(System.Object)">
            <summary>
            ArgumentException with message like "Method {0} contains generic parameters"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.MethodIsGeneric(System.Object)">
            <summary>
            ArgumentException with message like "Method {0} is a generic method definition"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.MethodNotPropertyAccessor(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "The method '{0}.{1}' is not a property accessor"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.PropertyDoesNotHaveGetter(System.Object)">
            <summary>
            ArgumentException with message like "The property '{0}' has no 'get' accessor"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.PropertyDoesNotHaveSetter(System.Object)">
            <summary>
            ArgumentException with message like "The property '{0}' has no 'set' accessor"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.PropertyDoesNotHaveAccessor(System.Object)">
            <summary>
            ArgumentException with message like "The property '{0}' has no 'get' or 'set' accessors"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.NotAMemberOfType(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "'{0}' is not a member of type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.OperatorNotImplementedForType(System.Object,System.Object)">
            <summary>
            NotImplementedException with message like "The operator '{0}' is not implemented for type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ParameterExpressionNotValidAsDelegate(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "ParameterExpression of type '{0}' cannot be used for delegate parameter of type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.PropertyNotDefinedForType(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Property '{0}' is not defined for type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.InstancePropertyNotDefinedForType(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Instance property '{0}' is not defined for type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.PropertyInfoNotDefinedForType(System.Object,System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Property '{0}.{1}' is not defined for type '{2}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.MethodNotDefinedForType(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Method '{0}' is not defined for type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.TypeContainsGenericParameters(System.Object)">
            <summary>
            ArgumentException with message like "Type {0} contains generic parameters"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.TypeIsGeneric(System.Object)">
            <summary>
            ArgumentException with message like "Type {0} is a generic type definition"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.TypeMissingDefaultConstructor(System.Object)">
            <summary>
            ArgumentException with message like "Type '{0}' does not have a default constructor"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ListInitializerWithZeroMembers">
            <summary>
            ArgumentException with message like "List initializers must contain at least one initializer"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ElementInitializerMethodNotAdd">
            <summary>
            ArgumentException with message like "Element initializer method must be named 'Add'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ElementInitializerMethodNoRefOutParam(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Parameter '{0}' of element initializer method '{1}' must not be a pass by reference parameter"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ElementInitializerMethodWithZeroArgs">
            <summary>
            ArgumentException with message like "Element initializer method must have at least 1 parameter"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ElementInitializerMethodStatic">
            <summary>
            ArgumentException with message like "Element initializer method must be an instance method"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.TypeNotIEnumerable(System.Object)">
            <summary>
            ArgumentException with message like "Type '{0}' is not IEnumerable"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.TypeParameterIsNotDelegate(System.Object)">
            <summary>
            InvalidOperationException with message like "Type parameter is {0}. Expected a delegate."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.UnexpectedCoalesceOperator">
            <summary>
            InvalidOperationException with message like "Unexpected coalesce operator."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.InvalidCast(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "Cannot cast from type '{0}' to type '{1}"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.UnhandledBinary(System.Object)">
            <summary>
            ArgumentException with message like "Unhandled binary: {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.UnhandledBinding">
            <summary>
            ArgumentException with message like "Unhandled binding "
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.UnhandledBindingType(System.Object)">
            <summary>
            ArgumentException with message like "Unhandled Binding Type: {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.UnhandledConvert(System.Object)">
            <summary>
            ArgumentException with message like "Unhandled convert: {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.UnhandledExpressionType(System.Object)">
            <summary>
            ArgumentException with message like "Unhandled Expression Type: {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.UnhandledUnary(System.Object)">
            <summary>
            ArgumentException with message like "Unhandled unary: {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.UnknownBindingType">
            <summary>
            ArgumentException with message like "Unknown binding type"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.UserDefinedOpMustHaveConsistentTypes(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "The user-defined operator method '{1}' for operator '{0}' must have identical parameter and return types."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.UserDefinedOpMustHaveValidReturnType(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "The user-defined operator method '{1}' for operator '{0}' must return the same type as its parameter or a derived type."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.LogicalOperatorMustHaveBooleanOperators(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "The user-defined operator method '{1}' for operator '{0}' must have associated boolean True and False operators."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.MethodDoesNotExistOnType(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "No method '{0}' exists on type '{1}'."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.MethodWithArgsDoesNotExistOnType(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "No method '{0}' on type '{1}' is compatible with the supplied arguments."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.MethodWithMoreThanOneMatch(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "More than one method '{0}' on type '{1}' is compatible with the supplied arguments."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.IncorrectNumberOfTypeArgsForFunc">
            <summary>
            ArgumentException with message like "An incorrect number of type args were specified for the declaration of a Func type."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.IncorrectNumberOfTypeArgsForAction">
            <summary>
            ArgumentException with message like "An incorrect number of type args were specified for the declaration of an Action type."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ArgumentCannotBeOfTypeVoid">
            <summary>
            ArgumentException with message like "Argument type cannot be System.Void."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.NoOrInvalidRuleProduced">
            <summary>
            InvalidOperationException with message like "No or Invalid rule produced"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.FirstArgumentMustBeCallSite">
            <summary>
            ArgumentException with message like "First argument of delegate must be CallSite"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.BindingCannotBeNull">
            <summary>
            InvalidOperationException with message like "Bind cannot return null."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.BadDelegateData">
            <summary>
            InvalidOperationException with message like "Bad data bound to delegate."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.InvalidOperation(System.Object)">
            <summary>
            ArgumentException with message like "Invalid operation: '{0}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.OutOfRange(System.Object,System.Object)">
            <summary>
            ArgumentOutOfRangeException with message like "{0} must be greater than or equal to {1}"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.QueueEmpty">
            <summary>
            InvalidOperationException with message like "Queue empty."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.LabelTargetAlreadyDefined(System.Object)">
            <summary>
            InvalidOperationException with message like "Cannot redefine label '{0}' in an inner block."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.LabelTargetUndefined(System.Object)">
            <summary>
            InvalidOperationException with message like "Cannot jump to to undefined label '{0}'."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ControlCannotLeaveFinally">
            <summary>
            InvalidOperationException with message like "Control cannot leave a finally block."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ControlCannotLeaveFilterTest">
            <summary>
            InvalidOperationException with message like "Control cannot leave a filter test."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.AmbiguousJump(System.Object)">
            <summary>
            InvalidOperationException with message like "Cannot jump to ambiguous label '{0}'."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ControlCannotEnterTry">
            <summary>
            InvalidOperationException with message like "Control cannot enter a try block."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ControlCannotEnterExpression">
            <summary>
            InvalidOperationException with message like "Control cannot enter an expression--only statements can be jumped into."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ExtensionNotReduced">
            <summary>
            InvalidOperationException with message like "Extension should have been reduced."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.RtConstRequiresBundDelegate">
            <summary>
            InvalidOperationException with message like "Runtime constants require a bound delegate."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.InvalidLvalue(System.Object)">
            <summary>
            InvalidOperationException with message like "Invalid lvalue for assignment: {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.InvalidMemberType(System.Object)">
            <summary>
            InvalidOperationException with message like "Invalid member type: {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.UnknownLiftType(System.Object)">
            <summary>
            InvalidOperationException with message like "unknown lift type: '{0}'."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.InvalidOutputDir">
            <summary>
            ArgumentException with message like "Invalid output directory."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.InvalidAsmNameOrExtension">
            <summary>
            ArgumentException with message like "Invalid assembly name or file extension."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.StackChangedWhileEnumerationg">
            <summary>
            InvalidOperationException with message like "Stack changed while enumerating."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.CollectionReadOnly">
            <summary>
            NotSupportedException with message like "Collection is read-only."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.IllegalNewGenericParams(System.Object)">
            <summary>
            ArgumentException with message like "Cannot create instance of {0} because it contains generic parameters"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.UndefinedVariable(System.Object,System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "variable '{0}' of type '{1}' referenced from scope '{2}', but it is not defined"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.CannotCloseOverByRef(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "Cannot close over byref parameter '{0}' referenced in lambda '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.UnexpectedVarArgsCall(System.Object)">
            <summary>
            InvalidOperationException with message like "Unexpected VarArgs call to method '{0}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.RethrowRequiresCatch">
            <summary>
            InvalidOperationException with message like "Rethrow statement is valid only inside a Catch block."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.TryNotAllowedInFilter">
            <summary>
            InvalidOperationException with message like "Try expression is not allowed inside a filter body."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.MustRewriteToSameType(System.Object,System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "When called from '{0}', rewriting a node of type '{1}' should return a non-null value of the same type. Alternatively, override '{2}' and change it to not visit children of this type."
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.Compiler.VariableBinder">
            <summary>
            Determines if variables are closed over in nested lambdas and need to
            be hoisted.
            </summary>
        </member>
        <member name="T:Microsoft.Runtime.CompilerServices.Closure">
            <summary>
            If the delegate generated by the Lambda compiler needs to either be a
            closure, or close over constants, the delegate itself will close over
            the instance of this object.
            
            TODO: Prevent this from being exposed as public surface area. See what
            Linq v1 does with System.Runtime.CompilerServices.ExecutionScope
            </summary>
        </member>
        <member name="F:Microsoft.Runtime.CompilerServices.Closure.Constants">
            <summary>
            The constant pool
            </summary>
        </member>
        <member name="F:Microsoft.Runtime.CompilerServices.Closure.Locals">
            <summary>
            The environment, which stores closed over variables from the parent
            scope
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.DynamicExpression">
            <summary>
            A late-bound operation. The precise semantics is determined by the
            Binder. If the Binder is one of the standard dynamic operations
            supported by MetaObject, the run-time behavior can be infered from the
            StandardAction
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.DynamicExpression.Rewrite(Microsoft.Linq.Expressions.Expression[])">
            <summary>
            Makes a copy of this node replacing the args with the provided values.  The 
            number of the args needs to match the number of the current block.
            
            This helper is provided to allow re-writing of nodes to not depend on the specific optimized
            subclass of DynamicExpression which is being used. 
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.DynamicExpression.Binder">
            <summary>
            The CallSiteBinder, which determines the runtime behavior of the
            dynamic site
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.DynamicExpression.DelegateType">
            <summary>
            The type of the CallSite's delegate
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.DynamicExpression.Arguments">
            <summary>
            Arguments to the dynamic operation
            </summary>
        </member>
        <member name="T:Microsoft.Action">
            <summary>
            Encapsulates a method that takes no parameters and does not return a value.
            </summary>
        </member>
        <member name="T:Microsoft.Action`2">
            <summary>
            Encapsulates a method that takes two parameters and does not return a value.
            </summary>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
        </member>
        <member name="T:Microsoft.Action`3">
            <summary>
            Encapsulates a method that takes three parameters and does not return a value.
            </summary>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
            <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
            <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
        </member>
        <member name="T:Microsoft.Action`4">
            <summary>
            Encapsulates a method that takes four parameters and does not return a value.
            </summary>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
            <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
            <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
            <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
        </member>
        <member name="T:Microsoft.Action`5">
            <summary>
            Encapsulates a method that takes five parameters and does not return a value.
            </summary>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
            <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
            <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
            <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
            <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
        </member>
        <member name="T:Microsoft.Action`6">
            <summary>
            Encapsulates a method that takes six parameters and does not return a value.
            </summary>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
            <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
            <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
            <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
            <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
            <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
        </member>
        <member name="T:Microsoft.Action`7">
            <summary>
            Encapsulates a method that takes seven parameters and does not return a value.
            </summary>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
            <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
            <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
            <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
            <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
            <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
            <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
        </member>
        <member name="T:Microsoft.Action`8">
            <summary>
            Encapsulates a method that takes eight parameters and does not return a value.
            </summary>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
            <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
            <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
            <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
            <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
            <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
            <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
            <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
        </member>
        <member name="T:Microsoft.Action`9">
            <summary>
            Encapsulates a method that takes nine parameters and does not return a value.
            </summary>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
            <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
            <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
            <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
            <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
            <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
            <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
            <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
            <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
        </member>
        <member name="T:Microsoft.Action`10">
            <summary>
            Encapsulates a method that takes ten parameters and does not return a value.
            </summary>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
            <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
            <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
            <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
            <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
            <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
            <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
            <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
            <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
            <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
        </member>
        <member name="T:Microsoft.Action`11">
            <summary>
            Encapsulates a method that takes eleven parameters and does not return a value.
            </summary>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates.</typeparam>
            <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
            <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
            <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
            <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
            <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
            <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
            <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
            <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
            <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
            <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
        </member>
        <member name="T:Microsoft.Action`12">
            <summary>
            Encapsulates a method that takes twelve parameters and does not return a value.
            </summary>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates.</typeparam>
            <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
            <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
            <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
            <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
            <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
            <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
            <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
            <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
            <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
            <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
            <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
        </member>
        <member name="T:Microsoft.Action`13">
            <summary>
            Encapsulates a method that takes thirteen parameters and does not return a value.
            </summary>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T13">The type of the thirteenth parameter of the method that this delegate encapsulates.</typeparam>
            <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
            <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
            <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
            <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
            <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
            <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
            <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
            <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
            <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
            <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
            <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
            <param name="arg13">The thirteenth parameter of the method that this delegate encapsulates.</param>
        </member>
        <member name="T:Microsoft.Action`14">
            <summary>
            Encapsulates a method that takes fourteen parameters and does not return a value.
            </summary>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T13">The type of the thirteenth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T14">The type of the fourteenth parameter of the method that this delegate encapsulates.</typeparam>
            <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
            <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
            <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
            <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
            <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
            <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
            <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
            <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
            <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
            <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
            <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
            <param name="arg13">The thirteenth parameter of the method that this delegate encapsulates.</param>
            <param name="arg14">The fourteenth parameter of the method that this delegate encapsulates.</param>
        </member>
        <member name="T:Microsoft.Action`15">
            <summary>
            Encapsulates a method that takes fifteen parameters and does not return a value.
            </summary>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T13">The type of the thirteenth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T14">The type of the fourteenth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T15">The type of the fifteenth parameter of the method that this delegate encapsulates.</typeparam>
            <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
            <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
            <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
            <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
            <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
            <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
            <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
            <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
            <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
            <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
            <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
            <param name="arg13">The thirteenth parameter of the method that this delegate encapsulates.</param>
            <param name="arg14">The fourteenth parameter of the method that this delegate encapsulates.</param>
            <param name="arg15">The fifteenth parameter of the method that this delegate encapsulates.</param>
        </member>
        <member name="T:Microsoft.Action`16">
            <summary>
            Encapsulates a method that takes sixteen parameters and does not return a value.
            </summary>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T13">The type of the thirteenth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T14">The type of the fourteenth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T15">The type of the fifteenth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T16">The type of the sixteenth parameter of the method that this delegate encapsulates.</typeparam>
            <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
            <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
            <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
            <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
            <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
            <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
            <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
            <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
            <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
            <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
            <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
            <param name="arg13">The thirteenth parameter of the method that this delegate encapsulates.</param>
            <param name="arg14">The fourteenth parameter of the method that this delegate encapsulates.</param>
            <param name="arg15">The fifteenth parameter of the method that this delegate encapsulates.</param>
            <param name="arg16">The sixteenth parameter of the method that this delegate encapsulates.</param>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.BeginCatchBlock(System.Type)">
            <summary>
            Begins a catch block.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.BeginExceptFilterBlock">
            <summary>
            Begins an exception block for a filtered exception.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.BeginExceptionBlock">
            <summary>
            Begins an exception block for a non-filtered exception.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.BeginFaultBlock">
            <summary>
            Begins an exception fault block
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.BeginFinallyBlock">
            <summary>
            Begins a finally block
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.EndExceptionBlock">
            <summary>
            Ends an exception block.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.BeginScope">
            <summary>
            Begins a lexical scope.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.EndScope">
            <summary>
            Ends a lexical scope.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.DeclareLocal(System.Type)">
            <summary>
            Declares a local variable of the specified type.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.DeclareLocal(System.Type,System.Boolean)">
            <summary>
            Declares a local variable of the specified type, optionally
            pinning the object referred to by the variable.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.DefineLabel">
            <summary>
            Declares a new label.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.MarkLabel(System.Reflection.Emit.Label)">
            <summary>
            Marks the label at the current position.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode)">
            <summary>
            Emits an instruction.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Byte)">
            <summary>
            Emits an instruction with a byte argument.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.ConstructorInfo)">
            <summary>
            Emits an instruction with the metadata token for the specified contructor.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Double)">
            <summary>
            Emits an instruction with a double argument.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.FieldInfo)">
            <summary>
            Emits an instruction with the metadata token for the specified field.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Single)">
            <summary>
            Emits an instruction with a float argument.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Int32)">
            <summary>
            Emits an instruction with an int argument.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label)">
            <summary>
            Emits an instruction with a label argument.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label[])">
            <summary>
            Emits an instruction with multiple target labels (switch).
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.LocalBuilder)">
            <summary>
            Emits an instruction with a reference to a local variable.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Int64)">
            <summary>
            Emits an instruction with a long argument.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo)">
            <summary>
            Emits an instruction with the metadata token for a specified method.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.SByte)">
            <summary>
            Emits an instruction with a signed byte argument.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Int16)">
            <summary>
            Emits an instruction with a short argument.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.SignatureHelper)">
            <summary>
            Emits an instruction with a signature token.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.String)">
            <summary>
            Emits an instruction with a string argument.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Type)">
            <summary>
            Emits an instruction with the metadata token for a specified type argument.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.EmitCall(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo,System.Type[])">
            <summary>
            Emits a call or a virtual call to the varargs method.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.EmitCalli(System.Reflection.Emit.OpCode,System.Runtime.InteropServices.CallingConvention,System.Type,System.Type[])">
            <summary>
            Emits an unmanaged indirect call instruction.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.EmitCalli(System.Reflection.Emit.OpCode,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[])">
            <summary>
            Emits a managed indirect call instruction.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.MarkSequencePoint(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Marks a sequence point.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.UsingNamespace(System.String)">
            <summary>
            Specifies the namespace to be used in evaluating locals and watches for the
                current active lexical scope.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.EmitLoadValueIndirect(System.Type)">
            <summary>
            Emits a Ldind* instruction for the appropriate type
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.EmitStoreValueIndirect(System.Type)">
            <summary>
            Emits a Stind* instruction for the appropriate type.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.EmitStoreElement(System.Type)">
            <summary>
            Emits a Stelem* instruction for the appropriate type.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.EmitBoxing(System.Type)">
            <summary>
            Boxes the value of the stack. No-op for reference types. Void is
            converted to a null reference. For almost all value types this
            method will box them in the standard way. Int32 and Boolean are
            handled with optimized conversions that reuse the same object for
            small values. For Int32 this is purely a performance optimization.
            For Boolean this is use to ensure that True and False are always
            the same objects.
            
            TODO: do we still need this?
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.EmitArray``1(System.Collections.Generic.IList{``0})">
            <summary>
            Emits an array of constant values provided in the given list.
            The array is strongly typed.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.EmitArray(System.Type,System.Int32,System.Action{System.Int32})">
            <summary>
            Emits an array of values of count size.  The items are emitted via the callback
            which is provided with the current item index to emit.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.EmitArray(System.Type)">
            <summary>
            Emits an array construction code.  
            The code assumes that bounds for all dimensions
            are already emitted.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.EmitDefault(System.Type)">
            <summary>
            Emits default(T)
            Semantics match C# compiler behavior
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.Compiler.StackSpiller">
            <summary>
            Expression rewriting to spill the CLR stack into temporary variables
            in order to guarantee some properties of code generation, for
            example that we always enter try block on empty stack.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.StackSpiller.RewriteExpression(Microsoft.Linq.Expressions.Expression,Microsoft.Linq.Expressions.Compiler.StackSpiller.Stack)">
            <summary>
            Rewrite the expression
            </summary>
            
            <param name="node">Expression to rewrite</param>
            <param name="stack">State of the stack before the expression is emitted.</param>
            <returns>Rewritten expression.</returns>
        </member>
        <member name="F:Microsoft.Linq.Expressions.Compiler.StackSpiller._tm">
            <summary>
            The source of temporary variables
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.StackSpiller.AnalyzeLambda(Microsoft.Linq.Expressions.LambdaExpression)">
            <summary>
            Analyzes a lambda, producing a new one that has correct invariants
            for codegen. In particular, it spills the IL stack to temps in
            places where it's invalid to have a non-empty stack (for example,
            entering a try statement).
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.StackSpiller.Clone``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.Int32)">
            <summary>
            Will clone an IList into an array of the same size, and copy
            all vaues up to (and NOT including) the max index
            </summary>
            <returns>The cloned array.</returns>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.StackSpiller.ToTemp(Microsoft.Linq.Expressions.Expression,Microsoft.Linq.Expressions.Expression@)">
            <summary>
            Will perform:
                save: temp = expression
                return value: temp
            </summary>
        </member>
        <member name="F:Microsoft.Linq.Expressions.Compiler.StackSpiller.TempMaker._temp">
            <summary>
            Current temporary variable
            </summary>
        </member>
        <member name="F:Microsoft.Linq.Expressions.Compiler.StackSpiller.TempMaker._freeTemps">
            <summary>
            List of free temporary variables. These can be recycled for new temps.
            </summary>
        </member>
        <member name="F:Microsoft.Linq.Expressions.Compiler.StackSpiller.TempMaker._usedTemps">
            <summary>
            Stack of currently active temporary variables.
            </summary>
        </member>
        <member name="F:Microsoft.Linq.Expressions.Compiler.StackSpiller.TempMaker._temps">
            <summary>
            List of all temps created by stackspiller for this rule/lambda
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.Compiler.StackSpiller.ChildRewriter">
            <summary>
            Rewrites child expressions, spilling them into temps if needed. The
            stack starts in the inital state, and after the first subexpression
            is added it is change to non-empty. This behavior can be overriden
            by setting the stack manually between adds.
            
            When all children have been added, the caller should rewrite the 
            node if Rewrite is true. Then, it should call crFinish with etiher
            the orignal expression or the rewritten expression. Finish will call
            Expression.Comma if necessary and return a new Result.
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.BlockExpression">
            <summary>
            Defines a block where variables are defined. The compiler will
            automatically close over these variables if they're referenced in a
            nested LambdaExpession.
            
            Specialized subclasses exist which actually implement the storage
            for the BlockExpression.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.BlockExpression.Rewrite(System.Collections.Generic.IList{Microsoft.Linq.Expressions.ParameterExpression},Microsoft.Linq.Expressions.Expression[])">
            <summary>
            Makes a copy of this node replacing the parameters/args with the provided values.  The 
            shape of the parameters/args needs to match the shape of the current block - in other
            words there should be the same # of parameters and args.
            
            parameters can be null in which case the existing parameters are used.
            
            This helper is provided to allow re-writing of nodes to not depend on the specific optimized
            subclass of BlockExpression which is being used. 
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.BlockExpression.ReturnReadOnlyExpressions(Microsoft.Linq.Expressions.BlockExpression,System.Object@)">
            <summary>
            Helper used for ensuring we only return 1 instance of a ReadOnlyCollection of T.
            
            This is similar to the ReturnReadOnly which only takes a single argument. This version
            supports nodes which hold onto 5 Expressions and puts all of the arguments into the
            ReadOnlyCollection.
            
            Ultimately this means if we create the ROC we will be slightly more wasteful as we'll
            have a ROC + some fields in the type.  The DLR internally avoids accessing anything
            which would force the ROC to be created.
            
            This is used by BlockExpression5 and MethodCallExpression5.
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.BlockExpression.Variables">
            <summary>
            The variables in this block.
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.BlockExpressionList">
            <summary>
            Provides a wrapper around an IArgumentProvider which exposes the argument providers
            members out as an IList of Expression.  This is used to avoid allocating an array
            which needs to be stored inside of a ReadOnlyCollection.  Instead this type has
            the same amount of overhead as an array without duplicating the storage of the
            elements.  This ensures that internally we can avoid creating and copying arrays
            while users of the Expression trees also don't pay a size penalty for this internal
            optimization.  See IArgumentProvider for more general information on the Expression
            tree optimizations being used here.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.UnaryOperationOnMemberBinder">
            <summary>
            A Binder that is responsible for runtime binding of operation:
            a.b (op)= c
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.UnaryOperationOnMemberBinder.#ctor(Microsoft.Linq.Expressions.ExpressionType,System.String,System.Boolean)">
            <summary>
            Constructor of the OperationOnIndexBinder object, representing "a.b (op)= c" operation.
            </summary>
            <param name="operation">Binary operation to be performed.</param>
            <param name="name">Name of the member for the operation.</param>
            <param name="ignoreCase">Ignore case of the member.</param>
        </member>
        <member name="M:Microsoft.Scripting.UnaryOperationOnMemberBinder.FallbackUnaryOperation(Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Implements a binding logic for the binary operation part of the binding.
            This is called by the target when the target implements the whole operation:
               a[b] += c
            as:
               a[b] = a[b] + c
            to let the language participate in the binding of the binary operation only.
            </summary>
            <param name="target">Target of the operation.</param>
            <returns>MetaObject representing the binding result.</returns>
        </member>
        <member name="M:Microsoft.Scripting.UnaryOperationOnMemberBinder.FallbackUnaryOperation(Microsoft.Scripting.DynamicMetaObject,Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Implements a binding logic for the binary operation part of the binding.
            This is called by the target when the target implements the whole operation:
               a[b] += c
            as:
               a[b] = a[b] + c
            to let the language participate in the binding of the binary operation only.
            </summary>
            <param name="target">Target of the operation.</param>
            <param name="errorSuggestion">The representaiton of the binding error that the target meta object recommends the language to use if the language cannot bind. This allows the target meta object to participate in the error handling process.</param>
            <returns>MetaObject representing the binding result.</returns>
        </member>
        <member name="M:Microsoft.Scripting.UnaryOperationOnMemberBinder.FallbackUnaryOperationOnMember(Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Implements a binding logic for the operation. This is called by the target when
            the target lets the executing language participate in the binding process.
            </summary>
            <param name="target">Target of the operation.</param>
            <returns>MetaObject representing the binding.</returns>
        </member>
        <member name="M:Microsoft.Scripting.UnaryOperationOnMemberBinder.FallbackUnaryOperationOnMember(Microsoft.Scripting.DynamicMetaObject,Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Implements a binding logic for the operation. This is called by the target when
            the target lets the executing language participate in the binding process.
            </summary>
            <param name="target">Target of the operation.</param>
            <param name="errorSuggestion">The representation of the binding error that the target meta
            object recommends the language to use if the language cannot bind.
            This allows the target meta object to participate in the error handling process.</param>
            <returns>MetaObject representing the binding.</returns>
        </member>
        <member name="M:Microsoft.Scripting.UnaryOperationOnMemberBinder.Equals(System.Object)">
            <summary>
            Implements Equality operation for the OperationOnMemberBinder
            </summary>
            <param name="obj">Instance to comapre equal to.</param>
            <returns>true/false</returns>
        </member>
        <member name="M:Microsoft.Scripting.UnaryOperationOnMemberBinder.GetHashCode">
            <summary>
            Calculates hash code for the OperationOnMemberBinder
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="P:Microsoft.Scripting.UnaryOperationOnMemberBinder.Operation">
            <summary>
            The operation to be performed.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.UnaryOperationOnMemberBinder.Name">
            <summary>
            Name of the member for the operation.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.UnaryOperationOnMemberBinder.IgnoreCase">
            <summary>
            Ignore case of the member.
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.Compiler.KeyedQueue`2">
            <summary>
            A simple dictionary of queues, keyed off a particular type
            This is useful for storing free lists of variables
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.ListArgumentProvider">
            <summary>
            Provides a wrapper around an IArgumentProvider which exposes the argument providers
            members out as an IList of Expression.  This is used to avoid allocating an array
            which needs to be stored inside of a ReadOnlyCollection.  Instead this type has
            the same amount of overhead as an array without duplicating the storage of the
            elements.  This ensures that internally we can avoid creating and copying arrays
            while users of the Expression trees also don't pay a size penalty for this internal
            optimization.  See IArgumentProvider for more general information on the Expression
            tree optimizations being used here.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.Helpers.RepeatedArray``1(``0,System.Int32)">
            <summary>
            Creates an array of size count with each element initialized to item
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.TypeUtils.GetNumericConversionOrder(System.TypeCode,System.Int32@,System.Int32@)">
            <summary>
            Returns a numerical code of the size of a type.  All types get both a horizontal
            and vertical code.  Types that are lower in both dimensions have implicit conversions
            to types that are higher in both dimensions.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.TypeUtils.GetBooleanOperator(System.Type,System.String)">
            <summary>
            Searches for an operator method on the type. The method must have
            the specified signature, no generic arguments, and have the
            SpecialName bit set. Also searches inherited operator methods.
            
            NOTE: This was designed to satisfy the needs of op_True and
            op_False, because we have to do runtime lookup for those. It may
            not work right for unary operators in general.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.TypeUtils.GetTypeForBinding(System.Object)">
            <summary>
            Returns the System.Type for any object, including null.  The type of null
            is represented by None.Type and all other objects just return the 
            result of Object.GetType
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.TreeComparer.Compare(Microsoft.Linq.Expressions.Expression,Microsoft.Linq.Expressions.Expression,System.Collections.Generic.List{Microsoft.Linq.Expressions.ConstantExpression}@,System.Boolean@)">
            <summary>
            Compares two trees.  If the trees differ only by constants then the list of constants which differ
            is provided as a list via an out-param.  The constants collected are the constants in the left
            side of the tree and only include constants which differ in value.
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.TreeComparer.FlatTreeWalker">
            <summary>
            Walks all of the nodes of a tree and puts all of the expressions into
            a list.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.UpdateDelegates.MatchmakerCache`1">
            <summary>
            Caches a single Matchmaker and its delegate to avoid expensive delegate
            recreation.  We just Interlock.Exchange this out each time we need one
            and replace it when we're done.  If multiple threads are operating we'll
            sometimes end up creating multiple delegates which is as bad w/o the
            cache.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.ExpressionStringBuilder.ExpressionToString(Microsoft.Linq.Expressions.Expression)">
            <summary>
            Output a given expression tree to a string.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.ExpressionStringBuilder.MemberBindingToString(Microsoft.Linq.Expressions.MemberBinding)">
            <summary>
            Output a given member binding to a string.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.ExpressionStringBuilder.ElementInitBindingToString(Microsoft.Linq.Expressions.ElementInit)">
            <summary>
            Output a given ElementInit to a string.
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.Compiler.ArgumentPrepender">
            <summary>
            Prepends an argument and stands in as an IArgumentProvider.  Avoids
            creation of a ReadOnlyCollection or making a temporary array copy.
            
            Note this is always as better than allocating an array because an empty
            array has 16 bytes of overhead - and so does this.
            </summary>
        </member>
        <member name="T:Microsoft.Runtime.CompilerServices.CallSiteRule`1">
            <summary>
            This type is only used by CallSite internally. Do not use
            </summary>
        </member>
        <member name="F:Microsoft.Runtime.CompilerServices.CallSiteRule`1.RuleSet">
            <summary>
            The rule set that includes only this rule.
            </summary>
        </member>
        <member name="F:Microsoft.Runtime.CompilerServices.CallSiteRule`1._binding">
            <summary>
            The binding expression tree
            </summary>
        </member>
        <member name="F:Microsoft.Runtime.CompilerServices.CallSiteRule`1._template">
            <summary>
            Template data - null for methods which aren't templated.  Non-null for methods which
            have been templated.  The same template data is shared across all templated rules with
            the same target method.
            </summary>
        </member>
        <member name="P:Microsoft.Runtime.CompilerServices.CallSiteRule`1.Binding">
            <summary>
            The expression representing the bound operation
            </summary>
        </member>
        <member name="P:Microsoft.Runtime.CompilerServices.CallSiteRule`1.TemplateMethod">
            <summary>
            Gets or sets the method which is used for templating. If the rule is
            not templated then this is a nop (and returns null for the getter).
            
            The method is tracked here independently from the delegate for the
            common case of the method being a DynamicMethod.  In order to re-bind
            the existing DynamicMethod to a new set of templated parameters we need
            to have the original method.
            </summary>
        </member>
        <member name="T:Microsoft.Runtime.CompilerServices.TemplateData`1">
            <summary>
            Data used for tracking templating information in a rule.
            
            Currently we just track the method so we can retarget to
            new constant pools.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.BinaryOperationOnMemberBinder">
            <summary>
            A Binder that is responsible for runtime binding of operation:
            a.b (op)= c
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.BinaryOperationOnMemberBinder.#ctor(Microsoft.Linq.Expressions.ExpressionType,System.String,System.Boolean)">
            <summary>
            Constructor of the OperationOnIndexBinder object, representing "a.b (op)= c" operation.
            </summary>
            <param name="operation">Binary operation to be performed.</param>
            <param name="name">Name of the member for the operation.</param>
            <param name="ignoreCase">Ignore case of the member.</param>
        </member>
        <member name="M:Microsoft.Scripting.BinaryOperationOnMemberBinder.FallbackBinaryOperation(Microsoft.Scripting.DynamicMetaObject,Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Implements a binding logic for the binary operation part of the binding.
            This is called by the target when the target implements the whole operation:
               a[b] += c
            as:
               a[b] = a[b] + c
            to let the language participate in the binding of the binary operation only.
            </summary>
            <param name="target">Target of the operation.</param>
            <param name="arg">Right-hand operator value</param>
            <returns>MetaObject representing the binding result.</returns>
        </member>
        <member name="M:Microsoft.Scripting.BinaryOperationOnMemberBinder.FallbackBinaryOperation(Microsoft.Scripting.DynamicMetaObject,Microsoft.Scripting.DynamicMetaObject,Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Implements a binding logic for the binary operation part of the binding.
            This is called by the target when the target implements the whole operation:
               a[b] += c
            as:
               a[b] = a[b] + c
            to let the language participate in the binding of the binary operation only.
            </summary>
            <param name="target">Target of the operation.</param>
            <param name="arg">Right-hand operator value</param>
            <param name="errorSuggestion">The representaiton of the binding error that the target meta object recommends the language to use if the language cannot bind. This allows the target meta object to participate in the error handling process.</param>
            <returns>MetaObject representing the binding result.</returns>
        </member>
        <member name="M:Microsoft.Scripting.BinaryOperationOnMemberBinder.FallbackBinaryOperationOnMember(Microsoft.Scripting.DynamicMetaObject,Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Implements a binding logic for the operation. This is called by the target when
            the target lets the executing language participate in the binding process.
            </summary>
            <param name="target">Target of the operation.</param>
            <param name="value">The right-hand value</param>
            <returns>MetaObject representing the binding.</returns>
        </member>
        <member name="M:Microsoft.Scripting.BinaryOperationOnMemberBinder.FallbackBinaryOperationOnMember(Microsoft.Scripting.DynamicMetaObject,Microsoft.Scripting.DynamicMetaObject,Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Implements a binding logic for the operation. This is called by the target when
            the target lets the executing language participate in the binding process.
            </summary>
            <param name="target">Target of the operation.</param>
            <param name="value">The right-hand value</param>
            <param name="errorSuggestion">The representaiton of the binding error that the target meta object recommends the language to use if the language cannot bind. This allows the target meta object to participate in the error handling process.</param>
            <returns>MetaObject representing the binding.</returns>
        </member>
        <member name="M:Microsoft.Scripting.BinaryOperationOnMemberBinder.Equals(System.Object)">
            <summary>
            Implements Equality operation for the OperationOnMemberBinder
            </summary>
            <param name="obj">Instance to comapre equal to.</param>
            <returns>true/false</returns>
        </member>
        <member name="M:Microsoft.Scripting.BinaryOperationOnMemberBinder.GetHashCode">
            <summary>
            Calculates hash code for the OperationOnMemberBinder
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="P:Microsoft.Scripting.BinaryOperationOnMemberBinder.Operation">
            <summary>
            The operation to be performed.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.BinaryOperationOnMemberBinder.Name">
            <summary>
            Name of the member for the operation.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.BinaryOperationOnMemberBinder.IgnoreCase">
            <summary>
            Ignore case of the member.
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.MemberExpression">
            <summary>
            Member expression (statically typed) which represents 
            property or field access, both static and instance.
            For instance property/field, Expression must be != null.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.UnaryOperationOnIndexBinder">
            <summary>
            A Binder that is responsible for runtime binding of operation:
            (op) a[b]
            For example : ++ a[b]
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.UnaryOperationOnIndexBinder.#ctor(Microsoft.Linq.Expressions.ExpressionType,Microsoft.Linq.Expressions.ArgumentInfo[])">
            <summary>
            The constructor of the OperationOnIndexBinder object, representing "(op) a[b]" operation.
            </summary>
            <param name="operation">Binary operation to be performed.</param>
            <param name="arguments">Description of the indexes (named, positional)</param>
        </member>
        <member name="M:Microsoft.Scripting.UnaryOperationOnIndexBinder.Equals(System.Object)">
            <summary>
            Implements Equality operation for the OperationOnIndexBinder
            </summary>
            <param name="obj">Instance to comapre equal to.</param>
            <returns>true/false</returns>
        </member>
        <member name="M:Microsoft.Scripting.UnaryOperationOnIndexBinder.GetHashCode">
            <summary>
            Calculates hash code for the OperationOnIndexBinder
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="M:Microsoft.Scripting.UnaryOperationOnIndexBinder.Bind(Microsoft.Scripting.DynamicMetaObject,Microsoft.Scripting.DynamicMetaObject[])">
            <summary>
            Performs binding of the operation on the target (represented as meta object) and
            list of arguments (indexes and right-hand value) represented as meta objects
            </summary>
            <param name="target">Target of the operation.</param>
            <param name="args">List of indexes and right-hand value</param>
            <returns>MetaObject representing the binding.</returns>
        </member>
        <member name="M:Microsoft.Scripting.UnaryOperationOnIndexBinder.FallbackUnaryOperation(Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Implements a binding logic for the binary operation part of the binding.
            This is called by the target when the target implements the whole operation:
               (op) a[b]
            as:
               a[b] = (op) a[b]
            to let the language participate in the binding of the binary operation only.
            </summary>
            <param name="target">Target of the operation.</param>
            <returns>MetaObject representing the binding result.</returns>
        </member>
        <member name="M:Microsoft.Scripting.UnaryOperationOnIndexBinder.FallbackUnaryOperation(Microsoft.Scripting.DynamicMetaObject,Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Implements a binding logic for the binary operation part of the binding.
            This is called by the target when the target implements the whole operation:
               (op) a[b]
            as:
               a[b] = (op) a[b]
            to let the language participate in the binding of the binary operation only.
            </summary>
            <param name="target">Target of the operation.</param>
            <param name="errorSuggestion">The representaiton of the binding error that the target meta object recommends the language to use if the language cannot bind. This allows the target meta object to participate in the error handling process.</param>
            <returns>MetaObject representing the binding result.</returns>
        </member>
        <member name="M:Microsoft.Scripting.UnaryOperationOnIndexBinder.FallbackUnaryOperationOnIndex(Microsoft.Scripting.DynamicMetaObject,Microsoft.Scripting.DynamicMetaObject[])">
            <summary>
            Implements a binding logic for the operation. This is called by the target when
            the target lets the executing language participate in the binding process.
            </summary>
            <param name="target">Target of the operation.</param>
            <param name="indexes">List of indexes and right-hand value</param>
            <returns>MetaObject representing the binding.</returns>
        </member>
        <member name="M:Microsoft.Scripting.UnaryOperationOnIndexBinder.FallbackUnaryOperationOnIndex(Microsoft.Scripting.DynamicMetaObject,Microsoft.Scripting.DynamicMetaObject[],Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Implements a binding logic for the operation. This is called by the target when
            the target lets the executing language participate in the binding process.
            </summary>
            <param name="target">Target of the operation.</param>
            <param name="indexes">List of indexes and right-hand value</param>
            <param name="errorSuggestion">The representaiton of the binding error that the target meta object recommends the language to use if the language cannot bind. This allows the target meta object to participate in the error handling process.</param>
            <returns>MetaObject representing the binding.</returns>
        </member>
        <member name="P:Microsoft.Scripting.UnaryOperationOnIndexBinder.Operation">
            <summary>
            The operation to be performed.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.UnaryOperationOnIndexBinder.Arguments">
            <summary>
            Descriptions of arguments to the indexer. This allows for named and positional arguments.
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.Compiler.HoistedLocals">
            <summary>
            Stores information about locals and arguments that are hoisted into
            the closure array because they're referenced in an inner lambda.
            
            This class is sometimes emitted as a runtime constant for internal
            use to hoist variables/parameters in quoted expressions
            
            Invariant: this class stores no mutable state
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.LambdaExpression">
            <summary>
            This captures a block of code that should correspond to a .NET method
            body. It takes input through parameters and is expected to be fully
            bound. This code can then be generated in a variety of ways. The
            variables can be kept as .NET locals or hoisted into an object bound to
            the delegate. This is the primary unit used for passing around
            Expression Trees in LINQ and the DLR.
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.DebugInfoExpression">
            <summary>
            Wraps an expression, emitting a sequence point around it
            
            This allows the debugger to highlight the correct source code when
            debugging.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.DebugInfoExpression.Reduce">
            <summary>
            Returns the underlying expression
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.DebugInfoExpression.Document">
            <summary>
            Information about the source file
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.DebugInfoExpression.Expression">
            <summary>
            The underlying expression to be evaluated
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Compiler.Snippets.SnippetsDirectory">
            <summary>
            Directory where snippet assembly will be saved if SaveSnippets is set.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.MethodCallExpression.Rewrite(Microsoft.Linq.Expressions.Expression,System.Collections.Generic.IList{Microsoft.Linq.Expressions.Expression})">
            <summary>
            Returns a new MethodCallExpression replacing the existing instance/args with the
            newly provided instance and args.    Arguments can be null to use the existing
            arguments.
            
            This helper is provided to allow re-writing of nodes to not depend on the specific optimized
            subclass of MethodCallExpression which is being used. 
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.Compiler.Set`1">
            <summary>
            A simple hashset, built on Dictionary{K, V}
            
            TODO: should remove this in favor of HashSet{T}
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.LoopExpression">
            <summary>
            Represents an infinite loop. It can be exited with "break"
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.SmallRuleSet`1">
            <summary>
            This holds a set of rules for a particular DynamicSite.  Any given
            SmallRuleSet instance is immutable and therefore they may be cached
            and shared.  At the moment, the only ones that are shared are
            SmallRuleSets with a single rule.
            
            When a new rule is added, then a new SmallRuleSet will be created
            that contains all existing rules that are still considered valid with
            the new rule added to the front of the list.  The target generated for
            this type will simply try each of the rules in order and emit the
            standard DynamicSite.UpdateBindingAndInvoke fallback call at the end.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Microsoft.Scripting.ExpandoClass">
            <summary>
            Represents a dynamically assigned class.  Expando objects which share the same 
            members will share the same class.  Classes are dynamically assigned as the
            expando object gains members.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ExpandoClass.#ctor">
            <summary>
            Constructs the empty ExpandoClass.  This is the class used when an
            empty Expando object is initially constructed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ExpandoClass.#ctor(System.String[],System.Int32)">
            <summary>
            Constructs a new ExpandoClass that can hold onto the specified keys.  The
            keys must be sorted ordinally.  The hash code must be precalculated for 
            the keys.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ExpandoClass.FindNewClass(System.String,System.Boolean)">
            <summary>
            Finds or creates a new ExpandoClass given the existing set of keys
            in this ExpandoClass plus the new key to be added.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ExpandoClass.GetNewKeys(System.Object[])">
            <summary>
            Gets a new object array for storing the data that matches this
            ExpandoClass given the old ExpandoClass and the instances associated 
            data array.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ExpandoClass.GetTransitionList(System.Int32)">
            <summary>
            Gets the lists of transitions that are valid from this ExpandoClass
            to an ExpandoClass whos keys hash to the apporopriate hash code.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ExpandoClass.GetValueIndex(System.String,System.Boolean)">
            <summary>
            Gets the index at which the value should be stored for the specified name.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ExpandoClass.GetIndexName(System.Int32)">
            <summary>
            Gets the name of the specified index.  Used for getting the name to 
            create a new expando class when all we have is the class and old index.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.ExpandoClass.Keys">
            <summary>
            Gets the names of the keys that can be stored in the Expando class.  The
            list is sorted ordinally.
            </summary>
        </member>
        <member name="T:Microsoft.Runtime.CompilerServices.CallSite">
            <summary>
            A Dynamic Call Site base class. This type is used as a parameter type to the
            dynamic site targets. The first parameter of the delegate (T) below must be
            of this type.
            </summary>
        </member>
        <member name="F:Microsoft.Runtime.CompilerServices.CallSite._binder">
            <summary>
            The Binder responsible for binding operations at this call site.
            This binder is invoked by the UpdateAndExecute below if all Level 0,
            Level 1 and Level 2 caches experience cache miss.
            </summary>
        </member>
        <member name="M:Microsoft.Runtime.CompilerServices.CallSite.Create(System.Type,Microsoft.Runtime.CompilerServices.CallSiteBinder)">
            <summary>
            Creates a CallSite with the given delegate type and binder.
            </summary>
            <param name="delegateType">The CallSite delegate type.</param>
            <param name="binder">The CallSite binder.</param>
            <returns>The new CallSite.</returns>
        </member>
        <member name="P:Microsoft.Runtime.CompilerServices.CallSite.Binder">
            <summary>
            Class responsible for binding dynamic operations on the dynamic site.
            </summary>
        </member>
        <member name="T:Microsoft.Runtime.CompilerServices.CallSite`1">
            <summary>
            Dynamic site type.
            </summary>
            <typeparam name="T">The delegate type.</typeparam>
        </member>
        <member name="F:Microsoft.Runtime.CompilerServices.CallSite`1.Update">
            <summary>
            The update delegate. Called when the dynamic site experiences cache miss.
            </summary>
        </member>
        <member name="F:Microsoft.Runtime.CompilerServices.CallSite`1.Target">
            <summary>
            The Level 0 cache - a delegate specialized based on the site history.
            </summary>
        </member>
        <member name="F:Microsoft.Runtime.CompilerServices.CallSite`1.Rules">
            <summary>
            The Level 1 cache - a history of the dynamic site.
            </summary>
        </member>
        <member name="F:Microsoft.Runtime.CompilerServices.CallSite`1._cache">
            <summary>
            The Level 2 cache - all rules produced for the same generic instantiation
            of the dynamic site (all dynamic sites with matching delegate type).
            </summary>
        </member>
        <member name="M:Microsoft.Runtime.CompilerServices.CallSite`1.IfThen(Microsoft.Linq.Expressions.Expression,Microsoft.Linq.Expressions.Expression)">
            <summary>
            Behaves like an "if" statement in imperative languages. The type is
            always treated as void regardless of the body's type. The else
            branch is empty
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.ExpressionWriter.Dump(Microsoft.Linq.Expressions.Expression,System.String,System.IO.TextWriter)">
            <summary>
            Write out the given AST
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.LabelExpression">
            <summary>
            Represents a label, which can be placed in any Expression context. If
            it is jumped to, it will get the value provided by the corresponding
            GotoExpression. Otherwise, it gets the value in DefaultValue. If the
            Type equals System.Void, no value should be provided
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.LabelExpression.DefaultValue">
            <summary>
            The value of the LabelExpression when the label is reached through
            normal control flow (e.g. is not jumped to)
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.GotoExpression.Value">
            <summary>
            The value passed to the target, or null if the target is of type
            System.Void
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.GotoExpression.Target">
            <summary>
            The target label where this node jumps to
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.GotoExpression.Kind">
            <summary>
            The kind of the goto. For information purposes only.
            </summary>
        </member>
        <member name="F:Microsoft.Runtime.CompilerServices.StrongBox`1.Value">
            <summary>
            Gets the strongly typed value associated with the StrongBox.  This is explicitly
            exposed as a field instead of a property to enable loading the address of the field.
            </summary>
        </member>
        <member name="M:Microsoft.Runtime.CompilerServices.StrongBox`1.#ctor">
            <summary>
            Creates a new StrongBox which can receive a value when used in a reference call.
            TODO: review this new API
            </summary>
        </member>
        <member name="M:Microsoft.Runtime.CompilerServices.StrongBox`1.#ctor(`0)">
            <summary>
            Creates a new StrongBox with the specified value.
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:Microsoft.Func`1">
            <summary>
            Encapsulates a method that has no parameters and returns a value of the type specified by the TResult parameter.
            </summary>
            <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
            <returns>The return value of the method that this delegate encapsulates.</returns>
        </member>
        <member name="T:Microsoft.Func`2">
            <summary>
            Encapsulates a method that has one parameter and returns a value of the type specified by the TResult parameter.
            </summary>
            <typeparam name="T">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
            <param name="arg">The first parameter of the method that this delegate encapsulates.</param>
            <returns>The return value of the method that this delegate encapsulates.</returns>
        </member>
        <member name="T:Microsoft.Func`3">
            <summary>
            Encapsulates a method that has two parameters and returns a value of the type specified by the TResult parameter.
            </summary>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
            <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
            <returns>The return value of the method that this delegate encapsulates.</returns>
        </member>
        <member name="T:Microsoft.Func`4">
            <summary>
            Encapsulates a method that has three parameters and returns a value of the type specified by the TResult parameter.
            </summary>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
            <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
            <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
            <returns>The return value of the method that this delegate encapsulates.</returns>
        </member>
        <member name="T:Microsoft.Func`5">
            <summary>
            Encapsulates a method that has four parameters and returns a value of the type specified by the TResult parameter.
            </summary>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
            <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
            <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
            <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
            <returns>The return value of the method that this delegate encapsulates.</returns>
        </member>
        <member name="T:Microsoft.Func`6">
            <summary>
            Encapsulates a method that has five parameters and returns a value of the type specified by the TResult parameter.
            </summary>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
            <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
            <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
            <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
            <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
            <returns>The return value of the method that this delegate encapsulates.</returns>
        </member>
        <member name="T:Microsoft.Func`7">
            <summary>
            Encapsulates a method that has six parameters and returns a value of the type specified by the TResult parameter.
            </summary>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
            <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
            <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
            <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
            <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
            <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
            <returns>The return value of the method that this delegate encapsulates.</returns>
        </member>
        <member name="T:Microsoft.Func`8">
            <summary>
            Encapsulates a method that has seven parameters and returns a value of the type specified by the TResult parameter.
            </summary>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
            <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
            <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
            <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
            <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
            <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
            <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
            <returns>The return value of the method that this delegate encapsulates.</returns>
        </member>
        <member name="T:Microsoft.Func`9">
            <summary>
            Encapsulates a method that has eight parameters and returns a value of the type specified by the TResult parameter.
            </summary>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
            <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
            <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
            <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
            <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
            <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
            <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
            <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
            <returns>The return value of the method that this delegate encapsulates.</returns>
        </member>
        <member name="T:Microsoft.Func`10">
            <summary>
            Encapsulates a method that has nine parameters and returns a value of the type specified by the TResult parameter.
            </summary>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
            <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
            <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
            <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
            <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
            <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
            <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
            <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
            <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
            <returns>The return value of the method that this delegate encapsulates.</returns>
        </member>
        <member name="T:Microsoft.Func`11">
            <summary>
            Encapsulates a method that has ten parameters and returns a value of the type specified by the TResult parameter.
            </summary>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
            <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
            <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
            <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
            <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
            <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
            <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
            <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
            <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
            <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
            <returns>The return value of the method that this delegate encapsulates.</returns>
        </member>
        <member name="T:Microsoft.Func`12">
            <summary>
            Encapsulates a method that has eleven parameters and returns a value of the type specified by the TResult parameter.
            </summary>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
            <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
            <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
            <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
            <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
            <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
            <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
            <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
            <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
            <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
            <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
            <returns>The return value of the method that this delegate encapsulates.</returns>
        </member>
        <member name="T:Microsoft.Func`13">
            <summary>
            Encapsulates a method that has twelve parameters and returns a value of the type specified by the TResult parameter.
            </summary>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
            <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
            <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
            <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
            <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
            <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
            <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
            <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
            <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
            <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
            <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
            <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
            <returns>The return value of the method that this delegate encapsulates.</returns>
        </member>
        <member name="T:Microsoft.Func`14">
            <summary>
            Encapsulates a method that has thirteen parameters and returns a value of the type specified by the TResult parameter.
            </summary>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T13">The type of the thirteenth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
            <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
            <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
            <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
            <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
            <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
            <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
            <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
            <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
            <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
            <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
            <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
            <param name="arg13">The thirteenth parameter of the method that this delegate encapsulates.</param>
            <returns>The return value of the method that this delegate encapsulates.</returns>
        </member>
        <member name="T:Microsoft.Func`15">
            <summary>
            Encapsulates a method that has fourteen parameters and returns a value of the type specified by the TResult parameter.
            </summary>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T13">The type of the thirteenth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T14">The type of the fourteenth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
            <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
            <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
            <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
            <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
            <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
            <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
            <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
            <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
            <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
            <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
            <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
            <param name="arg13">The thirteenth parameter of the method that this delegate encapsulates.</param>
            <param name="arg14">The fourteenth parameter of the method that this delegate encapsulates.</param>
            <returns>The return value of the method that this delegate encapsulates.</returns>
        </member>
        <member name="T:Microsoft.Func`16">
            <summary>
            Encapsulates a method that has fifteen parameters and returns a value of the type specified by the TResult parameter.
            </summary>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T13">The type of the thirteenth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T14">The type of the fourteenth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T15">The type of the fifteenth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
            <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
            <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
            <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
            <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
            <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
            <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
            <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
            <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
            <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
            <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
            <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
            <param name="arg13">The thirteenth parameter of the method that this delegate encapsulates.</param>
            <param name="arg14">The fourteenth parameter of the method that this delegate encapsulates.</param>
            <param name="arg15">The fifteenth parameter of the method that this delegate encapsulates.</param>
            <returns>The return value of the method that this delegate encapsulates.</returns>
        </member>
        <member name="T:Microsoft.Func`17">
            <summary>
            Encapsulates a method that has sixteen parameters and returns a value of the type specified by the TResult parameter.
            </summary>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T13">The type of the thirteenth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T14">The type of the fourteenth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T15">The type of the fifteenth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T16">The type of the sixteenth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
            <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
            <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
            <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
            <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
            <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
            <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
            <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
            <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
            <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
            <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
            <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
            <param name="arg13">The thirteenth parameter of the method that this delegate encapsulates.</param>
            <param name="arg14">The fourteenth parameter of the method that this delegate encapsulates.</param>
            <param name="arg15">The fifteenth parameter of the method that this delegate encapsulates.</param>
            <param name="arg16">The sixteenth parameter of the method that this delegate encapsulates.</param>
            <returns>The return value of the method that this delegate encapsulates.</returns>
        </member>
        <member name="T:Microsoft.Linq.Expressions.ParameterExpression">
            <summary>
            Base class for specialized parameter expressions.  This version only holds onto the
            name which all subclasses need.  Specialized subclasses provide the type and by ref
            flags.
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.ByRefParameterExpression">
            <summary>
            Specialized subclass to avoid holding onto the byref flag in a 
            parameter expression.  This version always holds onto the expression
            type explicitly and therefore derives from TypedParameterExpression.
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.TypedParameterExpression">
            <summary>
            Specialized subclass which holds onto the type of the expression for
            uncommon types.
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.PrimitiveParameterExpression`1">
            <summary>
            Generic type to avoid needing explicit storage for primitive data types
            which are commonly used.
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.RuntimeVariablesExpression">
            <summary>
            An expression that provides runtime read/write access to variables.
            Needed to implement "eval" in dynamic languages.
            Evaluates to an instance of ILocalVariables at run time.
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.RuntimeVariablesExpression.Variables">
            <summary>
            The variables or parameters to provide access to
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.RuleTree`1">
            <summary>
            This uses linear search to find a rule.  Clearly that doesn't scale super well.
            We will address this in the future.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Microsoft.Scripting.RuleTree`1.FindApplicableRules(System.Object[])">
            <summary>
            Looks through the rule list, prunes invalid rules and returns rules that apply
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.BinaryOperationOnIndexBinder">
            <summary>
            A Binder that is responsible for runtime binding of operation:
            a[b] (op)= c
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.BinaryOperationOnIndexBinder.#ctor(Microsoft.Linq.Expressions.ExpressionType,Microsoft.Linq.Expressions.ArgumentInfo[])">
            <summary>
            Constructor of the OperationOnIndexBinder object, representing "a[b] (op)= c" operation.
            </summary>
            <param name="operation">Binary operation to be performed.</param>
            <param name="arguments">Description of the indexes (named, positional)</param>
        </member>
        <member name="M:Microsoft.Scripting.BinaryOperationOnIndexBinder.Equals(System.Object)">
            <summary>
            Implements Equality operation for the OperationOnIndexBinder
            </summary>
            <param name="obj">Instance to comapre equal to.</param>
            <returns>true/false</returns>
        </member>
        <member name="M:Microsoft.Scripting.BinaryOperationOnIndexBinder.GetHashCode">
            <summary>
            Calculates hash code for the OperationOnIndexBinder
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="M:Microsoft.Scripting.BinaryOperationOnIndexBinder.Bind(Microsoft.Scripting.DynamicMetaObject,Microsoft.Scripting.DynamicMetaObject[])">
            <summary>
            Performs binding of the operation on the target (represented as meta object) and
            list of arguments (indexes and right-hand value) represented as meta objects
            </summary>
            <param name="target">Target of the operation.</param>
            <param name="args">List of indexes and right-hand value</param>
            <returns>MetaObject representing the binding.</returns>
        </member>
        <member name="M:Microsoft.Scripting.BinaryOperationOnIndexBinder.FallbackBinaryOperation(Microsoft.Scripting.DynamicMetaObject,Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Implements a binding logic for the binary operation part of the binding.
            This is called by the target when the target implements the whole operation:
               a[b] += c
            as:
               a[b] = a[b] + c
            to let the language participate in the binding of the binary operation only.
            </summary>
            <param name="target">Target of the operation.</param>
            <param name="arg">Right-hand operator value</param>
            <returns>MetaObject representing the binding result.</returns>
        </member>
        <member name="M:Microsoft.Scripting.BinaryOperationOnIndexBinder.FallbackBinaryOperation(Microsoft.Scripting.DynamicMetaObject,Microsoft.Scripting.DynamicMetaObject,Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Implements a binding logic for the binary operation part of the binding.
            This is called by the target when the target implements the whole operation:
               a[b] += c
            as:
               a[b] = a[b] + c
            to let the language participate in the binding of the binary operation only.
            </summary>
            <param name="target">Target of the operation.</param>
            <param name="arg">Right-hand operator value</param>
            <param name="errorSuggestion">The representaiton of the binding error that the target meta object recommends the language to use if the language cannot bind. This allows the target meta object to participate in the error handling process.</param>
            <returns>MetaObject representing the binding result.</returns>
        </member>
        <member name="M:Microsoft.Scripting.BinaryOperationOnIndexBinder.FallbackBinaryOperationOnIndex(Microsoft.Scripting.DynamicMetaObject,Microsoft.Scripting.DynamicMetaObject[],Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Implements a binding logic for the operation. This is called by the target when
            the target lets the executing language participate in the binding process.
            </summary>
            <param name="target">Target of the operation.</param>
            <param name="indexes">List of indexes</param>
            <param name="value">Right-hand value</param>
            <returns>MetaObject representing the binding.</returns>
        </member>
        <member name="M:Microsoft.Scripting.BinaryOperationOnIndexBinder.FallbackBinaryOperationOnIndex(Microsoft.Scripting.DynamicMetaObject,Microsoft.Scripting.DynamicMetaObject[],Microsoft.Scripting.DynamicMetaObject,Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Implements a binding logic for the operation. This is called by the target when
            the target lets the executing language participate in the binding process.
            </summary>
            <param name="target">Target of the operation.</param>
            <param name="indexes">List of indexes</param>
            <param name="value">Right-hand value</param>
            <param name="errorSuggestion">The representaiton of the binding error that the target meta object recommends the language to use if the language cannot bind. This allows the target meta object to participate in the error handling process.</param>
            <returns>MetaObject representing the binding.</returns>
        </member>
        <member name="P:Microsoft.Scripting.BinaryOperationOnIndexBinder.Operation">
            <summary>
            The operation to be performed.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.BinaryOperationOnIndexBinder.Arguments">
            <summary>
            Descriptions of arguments to the indexer. This allows for named and positional arguments.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.DynamicNull">
            <summary>
            Represents a type of a null value.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.DynamicNull.Type">
            <summary>
            The type of null value.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.DynamicNull.#ctor">
            <summary>
            Private constructor is never called since 'null' is the only valid instance.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.ConstantCheck.IsConstant(Microsoft.Linq.Expressions.Expression,System.Boolean)">
            <summary>
            Tests to see if the expression is a constant with the given value.
            </summary>
            <param name="e">The expression to examine</param>
            <param name="value">The constant value to check for.</param>
            <returns>true/false</returns>
        </member>
        <member name="M:Microsoft.Linq.Expressions.ConstantCheck.AnalyzeTypeIs(Microsoft.Linq.Expressions.TypeBinaryExpression)">
            <summary>
            If the result of a TypeBinaryExpression is known statically, this
            returns the result, otherwise it returns null, meaning we'll need
            to perform the IsInst instruction at runtime.
            
            The result of this function must be equivalent to IsInst, or
            null.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.ConstantCheck.AnalyzeTypeIs(Microsoft.Linq.Expressions.UnaryExpression)">
            <summary>
            If the result of a unary TypeAs expression is known statically, this
            returns the result, otherwise it returns null, meaning we'll need
            to perform the IsInst instruction at runtime.
            
            The result of this function must be equivalent to IsInst, or
            null.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.ConstantCheck.AnalyzeTypeIs(Microsoft.Linq.Expressions.Expression,System.Type)">
            <summary>
            If the result of an isinst opcode is known statically, this
            returns the result, otherwise it returns null, meaning we'll need
            to perform the IsInst instruction at runtime.
            
            The result of this function must be equivalent to IsInst, or
            null.
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.TryExpression">
            <summary>
            Represents a try/catch/finally/fault block.
            
            The body is protected by the try block.
            The handlers consist of a set of CatchBlocks that can either be catch or filters.
            The fault runs if an exception is thrown.
            The finally runs regardless of how control exits the body.
            Only fault or finally can be supplied
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.DynamicObject">
            <summary>
            Provides a simple class that can be inherited from to create an object with dynamic behavior
            at runtime.  Subclasses can override the various binder methods (GetMember, SetMember, Call, etc...)
            to provide custom behavior that will be invoked at runtime.  
            
            If a method is not overridden then the Dynamic object does not directly support that behavior and 
            the call site will determine how the binder should be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.DynamicObject.#ctor">
            <summary>
            Enables derived types to create a new instance of Dynamic.  Dynamic instances cannot be
            directly instantiated because they have no implementation of dynamic behavior.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.DynamicObject.TryGetMember(Microsoft.Scripting.GetMemberBinder,System.Object@)">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of getting a member.
            
            When not overridden the call site requesting the binder determines the behavior.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.DynamicObject.TrySetMember(Microsoft.Scripting.SetMemberBinder,System.Object)">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of setting a member.
            
            When not overridden the call site requesting the binder determines the behavior.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.DynamicObject.TryDeleteMember(Microsoft.Scripting.DeleteMemberBinder)">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of deleting a member.
            
            When not overridden the call site requesting the binder determines the behavior.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.DynamicObject.TryInvokeMember(Microsoft.Scripting.InvokeMemberBinder,System.Object[],System.Object@)">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of calling a member
            in the expando.
            
            When not overridden the call site requesting the binder determines the behavior.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.DynamicObject.TryConvert(Microsoft.Scripting.ConvertBinder,System.Object@)">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of converting the
            Dynamic object to another type.
            
            When not overridden the call site requesting the binder determines the behavior.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.DynamicObject.TryCreateInstance(Microsoft.Scripting.CreateInstanceBinder,System.Object[],System.Object@)">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of creating an instance
            of the Dynamic object.
            
            When not overridden the call site requesting the binder determines the behavior.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.DynamicObject.TryInvoke(Microsoft.Scripting.InvokeBinder,System.Object[],System.Object@)">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of invoking the
            Dynamic object.
            
            When not overridden the call site requesting the binder determines the behavior.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.DynamicObject.TryBinaryOperation(Microsoft.Scripting.BinaryOperationBinder,System.Object,System.Object@)">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of
            performing a binary operation.
            
            When not overridden the call site requesting the binder determines the behavior.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.DynamicObject.TryUnaryOperation(Microsoft.Scripting.UnaryOperationBinder,System.Object@)">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of
            performing a unary operation.
            
            When not overridden the call site requesting the binder determines the behavior.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.DynamicObject.TryGetIndex(Microsoft.Scripting.GetIndexBinder,System.Object[],System.Object@)">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of
            performing a get index operation.
            
            When not overridden the call site requesting the binder determines the behavior.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.DynamicObject.TrySetIndex(Microsoft.Scripting.SetIndexBinder,System.Object[],System.Object)">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of
            performing a set index operation.
            
            When not overridden the call site requesting the binder determines the behavior.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.DynamicObject.TryDeleteIndex(Microsoft.Scripting.DeleteIndexBinder,System.Object[])">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of
            performing a delete index operation.
            
            When not overridden the call site requesting the binder determines the behavior.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.DynamicObject.TryBinaryOperationOnMember(Microsoft.Scripting.BinaryOperationOnMemberBinder,System.Object,System.Object@)">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of
            performing an operation on member "a.b (op)=c" operation.
            
            When not overridden the call site requesting the binder determines the behavior.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.DynamicObject.TryBinaryOperationOnIndex(Microsoft.Scripting.BinaryOperationOnIndexBinder,System.Object[],System.Object,System.Object@)">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of
            performing an operation on index "a[i,j,k] (op)= c" operation.
            
            When not overridden the call site requesting the binder determines the behavior.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.DynamicObject.TryUnaryOperationOnMember(Microsoft.Scripting.UnaryOperationOnMemberBinder,System.Object@)">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of
            performing an operation on member "a.b (op)" operation.
            
            When not overridden the call site requesting the binder determines the behavior.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.DynamicObject.TryUnaryOperationOnIndex(Microsoft.Scripting.UnaryOperationOnIndexBinder,System.Object[],System.Object@)">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of
            performing an operation on index "a[i,j,k] (op)" operation.
            
            When not overridden the call site requesting the binder determines the behavior.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.DynamicObject.Microsoft#Scripting#IDynamicObject#GetMetaObject(Microsoft.Linq.Expressions.Expression)">
            <summary>
            The provided MetaObject will dispatch to the Dynamic virtual methods.
            The object can be encapsulated inside of another MetaObject to
            provide custom behavior for individual actions.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.DynamicObject.MetaDynamic.CallMethodWithResult(System.String,Microsoft.Scripting.DynamicMetaObjectBinder,Microsoft.Linq.Expressions.Expression[],Microsoft.Scripting.DynamicObject.MetaDynamic.Fallback)">
            <summary>
            Helper method for generating a MetaObject which calls a
            specific method on Dynamic that returns a result
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.DynamicObject.MetaDynamic.CallMethodReturnLast(System.String,Microsoft.Scripting.DynamicMetaObjectBinder,Microsoft.Linq.Expressions.Expression[],Microsoft.Scripting.DynamicObject.MetaDynamic.Fallback)">
            <summary>
            Helper method for generating a MetaObject which calls a
            specific method on Dynamic, but uses one of the arguments for
            the result.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.DynamicObject.MetaDynamic.CallMethodNoResult(System.String,Microsoft.Scripting.DynamicMetaObjectBinder,Microsoft.Linq.Expressions.Expression[],Microsoft.Scripting.DynamicObject.MetaDynamic.Fallback)">
            <summary>
            Helper method for generating a MetaObject which calls a
            specific method on Dynamic, but uses one of the arguments for
            the result.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.DynamicObject.MetaDynamic.IsOverridden(System.String)">
            <summary>
            Checks if the derived type has overridden the specified method.  If there is no
            implementation for the method provided then Dynamic falls back to the base class
            behavior which lets the call site determine how the binder is performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.DynamicObject.MetaDynamic.GetRestrictions">
            <summary>
            Returns a Restrictions object which includes our current restrictions merged
            with a restriction limiting our type
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.DynamicObject.MetaDynamic.GetLimitedSelf">
            <summary>
            Returns our Expression converted to our known LimitType
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.Compiler.CompilerScope">
            <summary>
            CompilerScope is the data structure which the Compiler keeps information
            related to compiling scopes. It stores the following information:
              1. Parent relationship (for resolving variables)
              2. Information about hoisted variables
              3. Information for resolving closures
            
            Instances are produced by VariableBinder, which does a tree walk
            looking for scope nodes: LambdaExpression and BlockExpression.
            </summary>
        </member>
        <member name="F:Microsoft.Linq.Expressions.Compiler.CompilerScope._parent">
            <summary>
            parent scope, if any
            </summary>
        </member>
        <member name="F:Microsoft.Linq.Expressions.Compiler.CompilerScope.Node">
            <summary>
            The expression node for this scope
            </summary>
        </member>
        <member name="F:Microsoft.Linq.Expressions.Compiler.CompilerScope.NeedsClosure">
            <summary>
            Does this scope (or any inner scope) close over variables from any
            parent scope?
            Populated by VariableBinder
            </summary>
        </member>
        <member name="F:Microsoft.Linq.Expressions.Compiler.CompilerScope.Definitions">
            <summary>
            Variables defined in this scope, and whether they're hoisted or not
            Populated by VariableBinder
            </summary>
        </member>
        <member name="F:Microsoft.Linq.Expressions.Compiler.CompilerScope.ReferenceCount">
            <summary>
            Each variable referenced within this scope, and how often it was referenced
            Populated by VariableBinder
            
            Created lazily as we only use in about 1 out of 3 compiles when compiling rules.
            </summary>
        </member>
        <member name="F:Microsoft.Linq.Expressions.Compiler.CompilerScope.MergedScopes">
            <summary>
            Scopes whose variables were merged into this one
            
            Created lazily as we create hundreds of compiler scopes w/o merging scopes when compiling rules.
            </summary>
        </member>
        <member name="F:Microsoft.Linq.Expressions.Compiler.CompilerScope._hoistedLocals">
            <summary>
            The scope's hoisted locals, if any.
            Provides storage for variables that are referenced from nested lambdas
            </summary>
        </member>
        <member name="F:Microsoft.Linq.Expressions.Compiler.CompilerScope._closureHoistedLocals">
            <summary>
            The closed over hoisted locals
            </summary>
        </member>
        <member name="F:Microsoft.Linq.Expressions.Compiler.CompilerScope._locals">
            <summary>
            Mutable dictionary that maps non-hoisted variables to either local
            slots or argument slots
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.CompilerScope.Enter(Microsoft.Linq.Expressions.Compiler.LambdaCompiler,Microsoft.Linq.Expressions.Compiler.CompilerScope)">
            <summary>
            Called when entering a lambda/block. Performs all variable allocation
            needed, including creating hoisted locals and IL locals for accessing
            parent locals
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.CompilerScope.Exit">
            <summary>
            Frees unnamed locals, clears state associated with this compiler
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.CompilerScope.AddLocal(Microsoft.Linq.Expressions.Compiler.LambdaCompiler,Microsoft.Linq.Expressions.ParameterExpression)">
            <summary>
            Adds a new virtual variable corresponding to an IL local
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.CompilerScope.ResolveVariable(Microsoft.Linq.Expressions.ParameterExpression,Microsoft.Linq.Expressions.Compiler.HoistedLocals)">
            <summary>
            Resolve a local variable in this scope or a closed over scope
            Throws if the variable is defined
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Compiler.CompilerScope.NearestHoistedLocals">
            <summary>
            This scope's hoisted locals, or the closed over locals, if any
            Equivalent to: _hoistedLocals ?? _closureHoistedLocals
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.Compiler.BoundConstants">
            <summary>
            This type tracks "runtime" constants--live objects that appear in
            ConstantExpression nodes and must be bound to the delegate.
            </summary>
        </member>
        <member name="F:Microsoft.Linq.Expressions.Compiler.BoundConstants._values">
            <summary>
            The list of constants in the order they appear in the constant array
            </summary>
        </member>
        <member name="F:Microsoft.Linq.Expressions.Compiler.BoundConstants._indexes">
            <summary>
            The index of each constant in the constant array
            </summary>
        </member>
        <member name="F:Microsoft.Linq.Expressions.Compiler.BoundConstants._references">
            <summary>
            Each constant referenced within this lambda, and how often it was referenced
            </summary>
        </member>
        <member name="F:Microsoft.Linq.Expressions.Compiler.BoundConstants._cache">
            <summary>
            IL locals for storing frequently used constants
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.BoundConstants.AddReference(System.Object,System.Type)">
            <summary>
            Called by VariableBinder. Adds the constant to the list (if needed)
            and increases the reference count by one
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.BoundConstants.EmitConstant(Microsoft.Linq.Expressions.Compiler.LambdaCompiler,System.Object,System.Type)">
            <summary>
            Emits a live object as a constant
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.BoundConstants.EmitCacheConstants(Microsoft.Linq.Expressions.Compiler.LambdaCompiler)">
            <summary>
            Emit code to cache frequently used constants into IL locals,
            instead of pulling them out of the array each time
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.Compiler.BoundConstants.TypedConstant">
            <summary>
            Constants can emit themselves as different types
            For caching purposes, we need to treat each distinct Type as a
            seperate thing to cache. (If we have to cast it on the way out, it
            ends up using a JIT temp and defeats the purpose of caching the
            value in a local)
            </summary>
        </member>
        <member name="T:Microsoft.Runtime.CompilerServices.CallSiteOps">
            <summary>
            Do not use this type. It is for internal use by CallSite
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.CollectionExtensions.ToReadOnly``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Wraps the provided enumerable into a ReadOnlyCollection{T}
            
            Copies all of the data into a new array, so the data can't be
            changed after creation. The exception is if the enumerable is
            already a ReadOnlyCollection{T}, in which case we just return it.
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.LabelTarget">
            <summary>
            Used to denote the target of a GotoExpression
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.LabelTarget.Type">
            <summary>
            The type of value that is passed when jumping to the label
            (or System.Void if no value should be passed)
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.IndexExpression">
            <summary>
            Represents property or array indexing
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.IndexExpression.Indexer">
            <summary>
            If this is an indexed property, returns the property
            If this is an array indexing operation, returns null
            </summary>
        </member>
    </members>
</doc>
